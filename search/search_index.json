{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to samgeo","text":"<p>A Python package for segmenting geospatial data with the Segment Anything Model (SAM) \ud83d\uddfa\ufe0f</p> <p>The segment-geospatial package draws its inspiration from segment-anything-eo repository authored by Aliaksandr Hancharenka. To facilitate the use of the Segment Anything Model (SAM) for geospatial data, I have developed the segment-anything-py and segment-geospatial Python packages, which are now available on PyPI and conda-forge. My primary objective is to simplify the process of leveraging SAM for geospatial data analysis by enabling users to achieve this with minimal coding effort. I have adapted the source code of segment-geospatial from the segment-anything-eo repository, and credit for its original version goes to Aliaksandr Hancharenka.</p> <ul> <li>\ud83c\udd93 Free software: MIT license</li> <li>\ud83d\udcd6 Documentation: https://samgeo.gishub.org</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Download map tiles from Tile Map Service (TMS) servers and create GeoTIFF files</li> <li>Segment GeoTIFF files using the Segment Anything Model (SAM)</li> <li>Save segmentation results as common vector formats (GeoPackage, Shapefile, GeoJSON, etc.)</li> <li>Visualize segmentation results on interactive maps</li> </ul>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Segmenting satellite imagery</li> <li>Automatically generating object masks</li> <li>Segmenting satellite imagery with input prompts</li> </ul>"},{"location":"#demos","title":"Demos","text":"<ul> <li>Automatic mask generator</li> </ul> <ul> <li>Interactive segmentation with input prompts</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<p>Video tutorials are available on my YouTube Channel.</p> <p></p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This package was made possible by the following open source projects. Credit goes to the developers of these projects.</p> <ul> <li>segment-anything \ud83d\udcbb</li> <li>segment-anything-eo \ud83d\udef0\ufe0f</li> <li>tms2geotiff \ud83d\udcf7</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v050-may-10-2023","title":"v0.5.0 - May 10, 2023","text":"<p>New Features</p> <ul> <li>Added support for input prompts (#30)</li> </ul> <p>Improvements</p> <ul> <li>Fixed the batch processing bug (#29)</li> </ul> <p>Demos</p> <p></p>"},{"location":"changelog/#v040-may-6-2023","title":"v0.4.0 - May 6, 2023","text":"<p>New Features</p> <ul> <li>Added new methods to <code>SamGeo</code> class, including <code>show_masks</code>, <code>save_masks</code>, <code>show_anns</code>, making it much easier to save segmentation results in GeoTIFF and vector formats.</li> <li>Added new functions to <code>common</code> module, including <code>array_to_image</code>, <code>show_image</code>, <code>download_file</code>, <code>overlay_images</code>, <code>blend_images</code>, and <code>update_package</code></li> <li>Added tow more notebooks, including automatic_mask_generator and satellite-predictor</li> <li>Added <code>SamGeoPredictor</code> class</li> </ul> <p>Improvements</p> <ul> <li>Improved <code>SamGeo.generate()</code> method</li> <li>Improved docstrings and API reference</li> <li>Added demos to docs</li> </ul> <p>Demos</p> <ul> <li>Automatic mask generator</li> </ul> <p></p> <p>Contributors</p> <p>@darrenwiens</p>"},{"location":"changelog/#v030-apr-26-2023","title":"v0.3.0 - Apr 26, 2023","text":"<p>New Features</p> <ul> <li>Added several new functions, including <code>get_basemaps</code>, <code>reproject</code>, <code>tiff_to_shp</code>, and <code>tiff_to_geojson</code></li> <li>Added hundereds of new basemaps through xyzservices</li> </ul> <p>Improvement</p> <ul> <li>Fixed <code>tiff_to_vector</code> crs bug #12</li> <li>Add <code>crs</code> parameter to <code>tms_to_geotiff</code></li> </ul>"},{"location":"changelog/#v020-apr-21-2023","title":"v0.2.0 - Apr 21, 2023","text":"<p>New Features</p> <ul> <li>Added notebook example</li> <li>Added <code>SamGeo.generate</code> method</li> <li>Added <code>SamGeo.tiff_to_vector</code> method</li> </ul>"},{"location":"changelog/#v010-apr-19-2023","title":"v0.1.0 - Apr 19, 2023","text":"<p>New Features</p> <ul> <li>Added <code>SamGeo</code> class</li> <li>Added GitHub Actions</li> <li>Added notebook example</li> </ul>"},{"location":"changelog/#v001-apr-18-2023","title":"v0.0.1 - Apr 18, 2023","text":"<p>Initial release</p>"},{"location":"common/","title":"common module","text":"<p>The source code is adapted from https://github.com/aliaksandr960/segment-anything-eo. Credit to the author Aliaksandr Hancharenka.</p>"},{"location":"common/#samgeo.common.array_to_image","title":"<code>array_to_image(array, output, source=None, dtype=None, compress='deflate', **kwargs)</code>","text":"<p>Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>np.ndarray</code> <p>The NumPy array to be saved as a GeoTIFF.</p> required <code>output</code> <code>str</code> <p>The path to the output image.</p> required <code>source</code> <code>str</code> <p>The path to an existing GeoTIFF file with map projection information. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>np.dtype</code> <p>The data type of the output array. Defaults to None.</p> <code>None</code> <code>compress</code> <code>str</code> <p>The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".</p> <code>'deflate'</code> Source code in <code>samgeo/common.py</code> <pre><code>def array_to_image(\n    array, output, source=None, dtype=None, compress=\"deflate\", **kwargs\n):\n\"\"\"Save a NumPy array as a GeoTIFF using the projection information from an existing GeoTIFF file.\n\n    Args:\n        array (np.ndarray): The NumPy array to be saved as a GeoTIFF.\n        output (str): The path to the output image.\n        source (str, optional): The path to an existing GeoTIFF file with map projection information. Defaults to None.\n        dtype (np.dtype, optional): The data type of the output array. Defaults to None.\n        compress (str, optional): The compression method. Can be one of the following: \"deflate\", \"lzw\", \"packbits\", \"jpeg\". Defaults to \"deflate\".\n    \"\"\"\n\n    from PIL import Image\n\n    if isinstance(array, str) and os.path.exists(array):\n        array = cv2.imread(array)\n        array = cv2.cvtColor(array, cv2.COLOR_BGR2RGB)\n\n    if output.endswith(\".tif\") and source is not None:\n        with rasterio.open(source) as src:\n            crs = src.crs\n            transform = src.transform\n            if compress is None:\n                compress = src.compression\n\n        # Determine the minimum and maximum values in the array\n        min_value = np.min(array)\n        max_value = np.max(array)\n\n        if dtype is None:\n            # Determine the best dtype for the array\n            if min_value &gt;= 0 and max_value &lt;= 1:\n                dtype = np.float32\n            elif min_value &gt;= 0 and max_value &lt;= 255:\n                dtype = np.uint8\n            elif min_value &gt;= -128 and max_value &lt;= 127:\n                dtype = np.int8\n            elif min_value &gt;= 0 and max_value &lt;= 65535:\n                dtype = np.uint16\n            elif min_value &gt;= -32768 and max_value &lt;= 32767:\n                dtype = np.int16\n            else:\n                dtype = np.float64\n\n        # Convert the array to the best dtype\n        array = array.astype(dtype)\n\n        # Define the GeoTIFF metadata\n        if array.ndim == 2:\n            metadata = {\n                \"driver\": \"GTiff\",\n                \"height\": array.shape[0],\n                \"width\": array.shape[1],\n                \"count\": 1,\n                \"dtype\": array.dtype,\n                \"crs\": crs,\n                \"transform\": transform,\n            }\n        elif array.ndim == 3:\n            metadata = {\n                \"driver\": \"GTiff\",\n                \"height\": array.shape[0],\n                \"width\": array.shape[1],\n                \"count\": array.shape[2],\n                \"dtype\": array.dtype,\n                \"crs\": crs,\n                \"transform\": transform,\n            }\n\n        if compress is not None:\n            metadata[\"compress\"] = compress\n        else:\n            raise ValueError(\"Array must be 2D or 3D.\")\n\n        # Create a new GeoTIFF file and write the array to it\n        with rasterio.open(output, \"w\", **metadata) as dst:\n            if array.ndim == 2:\n                dst.write(array, 1)\n            elif array.ndim == 3:\n                for i in range(array.shape[2]):\n                    dst.write(array[:, :, i], i + 1)\n\n    else:\n        img = Image.fromarray(array)\n        img.save(output, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.bbox_to_xy","title":"<code>bbox_to_xy(src_fp, coords, coord_crs='epsg:4326', **kwargs)</code>","text":"<p>Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>src_fp</code> <code>str</code> <p>The source raster file path.</p> required <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [[minx, miny, maxx, maxy], [minx, miny, maxx, maxy], ...]</p> required <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of pixel coordinates in the format of [[minx, miny, maxx, maxy], ...]</p> Source code in <code>samgeo/common.py</code> <pre><code>def bbox_to_xy(\n    src_fp: str, coords: list, coord_crs: str = \"epsg:4326\", **kwargs\n) -&gt; list:\n\"\"\"Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.\n\n    Args:\n        src_fp (str): The source raster file path.\n        coords (list): A list of coordinates in the format of [[minx, miny, maxx, maxy], [minx, miny, maxx, maxy], ...]\n        coord_crs (str, optional): The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".\n\n    Returns:\n        list: A list of pixel coordinates in the format of [[minx, miny, maxx, maxy], ...]\n    \"\"\"\n\n    if isinstance(coords, str):\n        gdf = gpd.read_file(coords)\n        coords = gdf.geometry.bounds.values.tolist()\n        if gdf.crs is not None:\n            coord_crs = f\"epsg:{gdf.crs.to_epsg()}\"\n    elif isinstance(coords, np.ndarray):\n        coords = coords.tolist()\n    if isinstance(coords, dict):\n        import json\n\n        geojson = json.dumps(coords)\n        gdf = gpd.read_file(geojson, driver=\"GeoJSON\")\n        coords = gdf.geometry.bounds.values.tolist()\n\n    elif not isinstance(coords, list):\n        raise ValueError(\"coords must be a list of coordinates.\")\n\n    if not isinstance(coords[0], list):\n        coords = [coords]\n\n    new_coords = []\n\n    with rasterio.open(src_fp) as src:\n        width = src.width\n        height = src.height\n\n        for coord in coords:\n            minx, miny, maxx, maxy = coord\n\n            if coord_crs != src.crs:\n                minx, miny = transform_coords(minx, miny, coord_crs, src.crs, **kwargs)\n                maxx, maxy = transform_coords(maxx, maxy, coord_crs, src.crs, **kwargs)\n\n                rows1, cols1 = rasterio.transform.rowcol(\n                    src.transform, minx, miny, **kwargs\n                )\n                rows2, cols2 = rasterio.transform.rowcol(\n                    src.transform, maxx, maxy, **kwargs\n                )\n\n                new_coords.append([cols1, rows1, cols2, rows2])\n\n            else:\n                new_coords.append([minx, miny, maxx, maxy])\n\n    result = []\n\n    for coord in new_coords:\n        minx, miny, maxx, maxy = coord\n\n        if (\n            minx &gt;= 0\n            and miny &gt;= 0\n            and maxx &gt;= 0\n            and maxy &gt;= 0\n            and minx &lt; width\n            and miny &lt; height\n            and maxx &lt; width\n            and maxy &lt; height\n        ):\n            result.append(coord)\n\n    if len(result) == 0:\n        print(\"No valid pixel coordinates found.\")\n        return None\n    elif len(result) == 1:\n        return result[0]\n    elif len(result) &lt; len(coords):\n        print(\"Some coordinates are out of the image boundary.\")\n\n    return result\n</code></pre>"},{"location":"common/#samgeo.common.blend_images","title":"<code>blend_images(img1, img2, alpha=0.5, output=False, show=True, figsize=(12, 10), axis='off', **kwargs)</code>","text":"<p>Blends two images together using the addWeighted function from the OpenCV library.</p> <p>Parameters:</p> Name Type Description Default <code>img1</code> <code>numpy.ndarray</code> <p>The first input image on top represented as a NumPy array.</p> required <code>img2</code> <code>numpy.ndarray</code> <p>The second input image at the bottom represented as a NumPy array.</p> required <code>alpha</code> <code>float</code> <p>The weighting factor for the first image in the blend. By default, this is set to 0.5.</p> <code>0.5</code> <code>output</code> <code>str</code> <p>The path to the output image. Defaults to False.</p> <code>False</code> <code>show</code> <code>bool</code> <p>Whether to display the blended image. Defaults to True.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>The size of the figure. Defaults to (12, 10).</p> <code>(12, 10)</code> <code>axis</code> <code>str</code> <p>The axis of the figure. Defaults to \"off\".</p> <code>'off'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the cv2.addWeighted() function.</p> <code>{}</code> <p>Returns:</p> Type Description <code>numpy.ndarray</code> <p>The blended image as a NumPy array.</p> Source code in <code>samgeo/common.py</code> <pre><code>def blend_images(\n    img1,\n    img2,\n    alpha=0.5,\n    output=False,\n    show=True,\n    figsize=(12, 10),\n    axis=\"off\",\n    **kwargs,\n):\n\"\"\"\n    Blends two images together using the addWeighted function from the OpenCV library.\n\n    Args:\n        img1 (numpy.ndarray): The first input image on top represented as a NumPy array.\n        img2 (numpy.ndarray): The second input image at the bottom represented as a NumPy array.\n        alpha (float): The weighting factor for the first image in the blend. By default, this is set to 0.5.\n        output (str, optional): The path to the output image. Defaults to False.\n        show (bool, optional): Whether to display the blended image. Defaults to True.\n        figsize (tuple, optional): The size of the figure. Defaults to (12, 10).\n        axis (str, optional): The axis of the figure. Defaults to \"off\".\n        **kwargs: Additional keyword arguments to pass to the cv2.addWeighted() function.\n\n    Returns:\n        numpy.ndarray: The blended image as a NumPy array.\n    \"\"\"\n    # Resize the images to have the same dimensions\n    if isinstance(img1, str):\n        if img1.startswith(\"http\"):\n            img1 = download_file(img1)\n\n        if not os.path.exists(img1):\n            raise ValueError(f\"Input path {img1} does not exist.\")\n\n        img1 = cv2.imread(img1)\n\n    if isinstance(img2, str):\n        if img2.startswith(\"http\"):\n            img2 = download_file(img2)\n\n        if not os.path.exists(img2):\n            raise ValueError(f\"Input path {img2} does not exist.\")\n\n        img2 = cv2.imread(img2)\n\n    if img1.dtype == np.float32:\n        img1 = (img1 * 255).astype(np.uint8)\n\n    if img2.dtype == np.float32:\n        img2 = (img2 * 255).astype(np.uint8)\n\n    if img1.dtype != img2.dtype:\n        img2 = img2.astype(img1.dtype)\n\n    img1 = cv2.resize(img1, (img2.shape[1], img2.shape[0]))\n\n    # Blend the images using the addWeighted function\n    beta = 1 - alpha\n    blend_img = cv2.addWeighted(img1, alpha, img2, beta, 0, **kwargs)\n\n    if output:\n        array_to_image(blend_img, output, img2)\n\n    if show:\n        plt.figure(figsize=figsize)\n        plt.imshow(blend_img)\n        plt.axis(axis)\n        plt.show()\n    else:\n        return blend_img\n</code></pre>"},{"location":"common/#samgeo.common.check_file_path","title":"<code>check_file_path(file_path, make_dirs=True)</code>","text":"<p>Gets the absolute file path.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file.</p> required <code>make_dirs</code> <code>bool</code> <p>Whether to create the directory if it does not exist. Defaults to True.</p> <code>True</code> <p>Exceptions:</p> Type Description <code>FileNotFoundError</code> <p>If the directory could not be found.</p> <code>TypeError</code> <p>If the input directory path is not a string.</p> <p>Returns:</p> Type Description <code>str</code> <p>The absolute path to the file.</p> Source code in <code>samgeo/common.py</code> <pre><code>def check_file_path(file_path, make_dirs=True):\n\"\"\"Gets the absolute file path.\n\n    Args:\n        file_path (str): The path to the file.\n        make_dirs (bool, optional): Whether to create the directory if it does not exist. Defaults to True.\n\n    Raises:\n        FileNotFoundError: If the directory could not be found.\n        TypeError: If the input directory path is not a string.\n\n    Returns:\n        str: The absolute path to the file.\n    \"\"\"\n    if isinstance(file_path, str):\n        if file_path.startswith(\"~\"):\n            file_path = os.path.expanduser(file_path)\n        else:\n            file_path = os.path.abspath(file_path)\n\n        file_dir = os.path.dirname(file_path)\n        if not os.path.exists(file_dir) and make_dirs:\n            os.makedirs(file_dir)\n\n        return file_path\n\n    else:\n        raise TypeError(\"The provided file path must be a string.\")\n</code></pre>"},{"location":"common/#samgeo.common.coords_to_xy","title":"<code>coords_to_xy(src_fp, coords, coord_crs='epsg:4326', **kwargs)</code>","text":"<p>Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>src_fp</code> <code>str</code> <p>The source raster file path.</p> required <code>coords</code> <code>list</code> <p>A list of coordinates in the format of [[x1, y1], [x2, y2], ...]</p> required <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.transform.rowcol.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]</p> Source code in <code>samgeo/common.py</code> <pre><code>def coords_to_xy(\n    src_fp: str, coords: list, coord_crs: str = \"epsg:4326\", **kwargs\n) -&gt; list:\n\"\"\"Converts a list of coordinates to pixel coordinates, i.e., (col, row) coordinates.\n\n    Args:\n        src_fp: The source raster file path.\n        coords: A list of coordinates in the format of [[x1, y1], [x2, y2], ...]\n        coord_crs: The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".\n        **kwargs: Additional keyword arguments to pass to rasterio.transform.rowcol.\n\n    Returns:\n        A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]\n    \"\"\"\n    if isinstance(coords, np.ndarray):\n        coords = coords.tolist()\n\n    xs, ys = zip(*coords)\n    with rasterio.open(src_fp) as src:\n        width = src.width\n        height = src.height\n        if coord_crs != src.crs:\n            xs, ys = transform_coords(xs, ys, coord_crs, src.crs, **kwargs)\n        rows, cols = rasterio.transform.rowcol(src.transform, xs, ys, **kwargs)\n    result = [[col, row] for col, row in zip(cols, rows)]\n\n    result = [\n        [x, y] for x, y in result if x &gt;= 0 and y &gt;= 0 and x &lt; width and y &lt; height\n    ]\n    if len(result) == 0:\n        print(\"No valid pixel coordinates found.\")\n    elif len(result) &lt; len(coords):\n        print(\"Some coordinates are out of the image boundary.\")\n\n    return result\n</code></pre>"},{"location":"common/#samgeo.common.download_checkpoint","title":"<code>download_checkpoint(url=None, output=None, overwrite=False, **kwargs)</code>","text":"<p>Download a checkpoint from URL. It can be one of the following: sam_vit_h_4b8939.pth, sam_vit_l_0b3195.pth, sam_vit_b_01ec64.pth.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The checkpoint URL. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>The output file path. Defaults to None.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The output file path.</p> Source code in <code>samgeo/common.py</code> <pre><code>def download_checkpoint(url=None, output=None, overwrite=False, **kwargs):\n\"\"\"Download a checkpoint from URL. It can be one of the following: sam_vit_h_4b8939.pth, sam_vit_l_0b3195.pth, sam_vit_b_01ec64.pth.\n\n    Args:\n        url (str, optional): The checkpoint URL. Defaults to None.\n        output (str, optional): The output file path. Defaults to None.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n\n    Returns:\n        str: The output file path.\n    \"\"\"\n    checkpoints = {\n        \"sam_vit_h_4b8939.pth\": \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\",\n        \"sam_vit_l_0b3195.pth\": \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_l_0b3195.pth\",\n        \"sam_vit_b_01ec64.pth\": \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_b_01ec64.pth\",\n    }\n\n    if isinstance(url, str) and url in checkpoints:\n        url = checkpoints[url]\n\n    if url is None:\n        url = checkpoints[\"sam_vit_h_4b8939.pth\"]\n\n    if output is None:\n        output = os.path.basename(url)\n\n    return download_file(url, output, overwrite=overwrite, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.download_file","title":"<code>download_file(url=None, output=None, quiet=False, proxy=None, speed=None, use_cookies=True, verify=True, id=None, fuzzy=False, resume=False, unzip=True, overwrite=False, subfolder=False)</code>","text":"<p>Download a file from URL, including Google Drive shared URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Google Drive URL is also supported. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>Output filename. Default is basename of URL.</p> <code>None</code> <code>quiet</code> <code>bool</code> <p>Suppress terminal output. Default is False.</p> <code>False</code> <code>proxy</code> <code>str</code> <p>Proxy. Defaults to None.</p> <code>None</code> <code>speed</code> <code>float</code> <p>Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.</p> <code>None</code> <code>use_cookies</code> <code>bool</code> <p>Flag to use cookies. Defaults to True.</p> <code>True</code> <code>verify</code> <code>bool | str</code> <p>Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string, in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.</p> <code>True</code> <code>id</code> <code>str</code> <p>Google Drive's file ID. Defaults to None.</p> <code>None</code> <code>fuzzy</code> <code>bool</code> <p>Fuzzy extraction of Google Drive's file Id. Defaults to False.</p> <code>False</code> <code>resume</code> <code>bool</code> <p>Resume the download from existing tmp file if possible. Defaults to False.</p> <code>False</code> <code>unzip</code> <code>bool</code> <p>Unzip the file. Defaults to True.</p> <code>True</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the file if it already exists. Defaults to False.</p> <code>False</code> <code>subfolder</code> <code>bool</code> <p>Create a subfolder with the same name as the file. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The output file path.</p> Source code in <code>samgeo/common.py</code> <pre><code>def download_file(\n    url=None,\n    output=None,\n    quiet=False,\n    proxy=None,\n    speed=None,\n    use_cookies=True,\n    verify=True,\n    id=None,\n    fuzzy=False,\n    resume=False,\n    unzip=True,\n    overwrite=False,\n    subfolder=False,\n):\n\"\"\"Download a file from URL, including Google Drive shared URL.\n\n    Args:\n        url (str, optional): Google Drive URL is also supported. Defaults to None.\n        output (str, optional): Output filename. Default is basename of URL.\n        quiet (bool, optional): Suppress terminal output. Default is False.\n        proxy (str, optional): Proxy. Defaults to None.\n        speed (float, optional): Download byte size per second (e.g., 256KB/s = 256 * 1024). Defaults to None.\n        use_cookies (bool, optional): Flag to use cookies. Defaults to True.\n        verify (bool | str, optional): Either a bool, in which case it controls whether the server's TLS certificate is verified, or a string,\n            in which case it must be a path to a CA bundle to use. Default is True.. Defaults to True.\n        id (str, optional): Google Drive's file ID. Defaults to None.\n        fuzzy (bool, optional): Fuzzy extraction of Google Drive's file Id. Defaults to False.\n        resume (bool, optional): Resume the download from existing tmp file if possible. Defaults to False.\n        unzip (bool, optional): Unzip the file. Defaults to True.\n        overwrite (bool, optional): Overwrite the file if it already exists. Defaults to False.\n        subfolder (bool, optional): Create a subfolder with the same name as the file. Defaults to False.\n\n    Returns:\n        str: The output file path.\n    \"\"\"\n    import zipfile\n\n    try:\n        import gdown\n    except ImportError:\n        print(\n            \"The gdown package is required for this function. Use `pip install gdown` to install it.\"\n        )\n        return\n\n    if output is None:\n        if isinstance(url, str) and url.startswith(\"http\"):\n            output = os.path.basename(url)\n\n    out_dir = os.path.abspath(os.path.dirname(output))\n    if not os.path.exists(out_dir):\n        os.makedirs(out_dir)\n\n    if isinstance(url, str):\n        if os.path.exists(os.path.abspath(output)) and (not overwrite):\n            print(\n                f\"{output} already exists. Skip downloading. Set overwrite=True to overwrite.\"\n            )\n            return os.path.abspath(output)\n        else:\n            url = github_raw_url(url)\n\n    if \"https://drive.google.com/file/d/\" in url:\n        fuzzy = True\n\n    output = gdown.download(\n        url, output, quiet, proxy, speed, use_cookies, verify, id, fuzzy, resume\n    )\n\n    if unzip and output.endswith(\".zip\"):\n        with zipfile.ZipFile(output, \"r\") as zip_ref:\n            if not quiet:\n                print(\"Extracting files...\")\n            if subfolder:\n                basename = os.path.splitext(os.path.basename(output))[0]\n\n                output = os.path.join(out_dir, basename)\n                if not os.path.exists(output):\n                    os.makedirs(output)\n                zip_ref.extractall(output)\n            else:\n                zip_ref.extractall(os.path.dirname(output))\n\n    return os.path.abspath(output)\n</code></pre>"},{"location":"common/#samgeo.common.geojson_to_coords","title":"<code>geojson_to_coords(geojson, src_crs='epsg:4326', dst_crs='epsg:4326')</code>","text":"<p>Converts a geojson file or a dictionary of feature collection to a list of centroid coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>str | dict</code> <p>The geojson file path or a dictionary of feature collection.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of centroid coordinates in the format of [[x1, y1], [x2, y2], ...]</p> Source code in <code>samgeo/common.py</code> <pre><code>def geojson_to_coords(\n    geojson: str, src_crs: str = \"epsg:4326\", dst_crs: str = \"epsg:4326\"\n) -&gt; list:\n\"\"\"Converts a geojson file or a dictionary of feature collection to a list of centroid coordinates.\n\n    Args:\n        geojson (str | dict): The geojson file path or a dictionary of feature collection.\n        src_crs (str, optional): The source CRS. Defaults to \"epsg:4326\".\n        dst_crs (str, optional): The destination CRS. Defaults to \"epsg:4326\".\n\n    Returns:\n        list: A list of centroid coordinates in the format of [[x1, y1], [x2, y2], ...]\n    \"\"\"\n\n    import json\n    import warnings\n\n    warnings.filterwarnings(\"ignore\")\n\n    if isinstance(geojson, dict):\n        geojson = json.dumps(geojson)\n    gdf = gpd.read_file(geojson, driver=\"GeoJSON\")\n    centroids = gdf.geometry.centroid\n    centroid_list = [[point.x, point.y] for point in centroids]\n    if src_crs != dst_crs:\n        centroid_list = transform_coords(\n            [x[0] for x in centroid_list],\n            [x[1] for x in centroid_list],\n            src_crs,\n            dst_crs,\n        )\n        centroid_list = [[x, y] for x, y in zip(centroid_list[0], centroid_list[1])]\n    return centroid_list\n</code></pre>"},{"location":"common/#samgeo.common.geojson_to_xy","title":"<code>geojson_to_xy(src_fp, geojson, coord_crs='epsg:4326', **kwargs)</code>","text":"<p>Converts a geojson file or a dictionary of feature collection to a list of pixel coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>src_fp</code> <code>str</code> <p>The source raster file path.</p> required <code>geojson</code> <code>str</code> <p>The geojson file path or a dictionary of feature collection.</p> required <code>coord_crs</code> <code>str</code> <p>The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".</p> <code>'epsg:4326'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.transform.rowcol.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list</code> <p>A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]</p> Source code in <code>samgeo/common.py</code> <pre><code>def geojson_to_xy(\n    src_fp: str, geojson: str, coord_crs: str = \"epsg:4326\", **kwargs\n) -&gt; list:\n\"\"\"Converts a geojson file or a dictionary of feature collection to a list of pixel coordinates.\n\n    Args:\n        src_fp: The source raster file path.\n        geojson: The geojson file path or a dictionary of feature collection.\n        coord_crs: The coordinate CRS of the input coordinates. Defaults to \"epsg:4326\".\n        **kwargs: Additional keyword arguments to pass to rasterio.transform.rowcol.\n\n    Returns:\n        A list of pixel coordinates in the format of [[x1, y1], [x2, y2], ...]\n    \"\"\"\n    with rasterio.open(src_fp) as src:\n        src_crs = src.crs\n    coords = geojson_to_coords(geojson, coord_crs, src_crs)\n    return coords_to_xy(src_fp, coords, src_crs, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.get_basemaps","title":"<code>get_basemaps(free_only=True)</code>","text":"<p>Returns a dictionary of xyz basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>free_only</code> <code>bool</code> <p>Whether to return only free xyz tile services that do not require an access token. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of xyz basemaps.</p> Source code in <code>samgeo/common.py</code> <pre><code>def get_basemaps(free_only=True):\n\"\"\"Returns a dictionary of xyz basemaps.\n\n    Args:\n        free_only (bool, optional): Whether to return only free xyz tile services that do not require an access token. Defaults to True.\n\n    Returns:\n        dict: A dictionary of xyz basemaps.\n    \"\"\"\n\n    basemaps = {}\n    xyz_dict = get_xyz_dict(free_only=free_only)\n    for item in xyz_dict:\n        name = xyz_dict[item].name\n        url = xyz_dict[item].build_url()\n        basemaps[name] = url\n\n    return basemaps\n</code></pre>"},{"location":"common/#samgeo.common.get_vector_crs","title":"<code>get_vector_crs(filename, **kwargs)</code>","text":"<p>Gets the CRS of a vector file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The vector file path.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The CRS of the vector file.</p> Source code in <code>samgeo/common.py</code> <pre><code>def get_vector_crs(filename, **kwargs):\n\"\"\"Gets the CRS of a vector file.\n\n    Args:\n        filename (str): The vector file path.\n\n    Returns:\n        str: The CRS of the vector file.\n    \"\"\"\n    gdf = gpd.read_file(filename, **kwargs)\n    epsg = gdf.crs.to_epsg()\n    if epsg is None:\n        return gdf.crs\n    else:\n        return f\"EPSG:{epsg}\"\n</code></pre>"},{"location":"common/#samgeo.common.get_xyz_dict","title":"<code>get_xyz_dict(free_only=True)</code>","text":"<p>Returns a dictionary of xyz services.</p> <p>Parameters:</p> Name Type Description Default <code>free_only</code> <code>bool</code> <p>Whether to return only free xyz tile services that do not require an access token. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of xyz services.</p> Source code in <code>samgeo/common.py</code> <pre><code>def get_xyz_dict(free_only=True):\n\"\"\"Returns a dictionary of xyz services.\n\n    Args:\n        free_only (bool, optional): Whether to return only free xyz tile services that do not require an access token. Defaults to True.\n\n    Returns:\n        dict: A dictionary of xyz services.\n    \"\"\"\n    import collections\n    import xyzservices.providers as xyz\n\n    def _unpack_sub_parameters(var, param):\n        temp = var\n        for sub_param in param.split(\".\"):\n            temp = getattr(temp, sub_param)\n        return temp\n\n    xyz_dict = {}\n    for item in xyz.values():\n        try:\n            name = item[\"name\"]\n            tile = _unpack_sub_parameters(xyz, name)\n            if _unpack_sub_parameters(xyz, name).requires_token():\n                if free_only:\n                    pass\n                else:\n                    xyz_dict[name] = tile\n            else:\n                xyz_dict[name] = tile\n\n        except Exception:\n            for sub_item in item:\n                name = item[sub_item][\"name\"]\n                tile = _unpack_sub_parameters(xyz, name)\n                if _unpack_sub_parameters(xyz, name).requires_token():\n                    if free_only:\n                        pass\n                    else:\n                        xyz_dict[name] = tile\n                else:\n                    xyz_dict[name] = tile\n\n    xyz_dict = collections.OrderedDict(sorted(xyz_dict.items()))\n    return xyz_dict\n</code></pre>"},{"location":"common/#samgeo.common.github_raw_url","title":"<code>github_raw_url(url)</code>","text":"<p>Get the raw URL for a GitHub file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The GitHub URL.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The raw URL.</p> Source code in <code>samgeo/common.py</code> <pre><code>def github_raw_url(url):\n\"\"\"Get the raw URL for a GitHub file.\n\n    Args:\n        url (str): The GitHub URL.\n    Returns:\n        str: The raw URL.\n    \"\"\"\n    if isinstance(url, str) and url.startswith(\"https://github.com/\") and \"blob\" in url:\n        url = url.replace(\"github.com\", \"raw.githubusercontent.com\").replace(\n            \"blob/\", \"\"\n        )\n    return url\n</code></pre>"},{"location":"common/#samgeo.common.image_to_cog","title":"<code>image_to_cog(source, dst_path=None, profile='deflate', **kwargs)</code>","text":"<p>Converts an image to a COG file.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>A dataset path, URL or rasterio.io.DatasetReader object.</p> required <code>dst_path</code> <code>str</code> <p>An output dataset path or or PathLike object. Defaults to None.</p> <code>None</code> <code>profile</code> <code>str</code> <p>COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".</p> <code>'deflate'</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If rio-cogeo is not installed.</p> <code>FileNotFoundError</code> <p>If the source file could not be found.</p> Source code in <code>samgeo/common.py</code> <pre><code>def image_to_cog(source, dst_path=None, profile=\"deflate\", **kwargs):\n\"\"\"Converts an image to a COG file.\n\n    Args:\n        source (str): A dataset path, URL or rasterio.io.DatasetReader object.\n        dst_path (str, optional): An output dataset path or or PathLike object. Defaults to None.\n        profile (str, optional): COG profile. More at https://cogeotiff.github.io/rio-cogeo/profile. Defaults to \"deflate\".\n\n    Raises:\n        ImportError: If rio-cogeo is not installed.\n        FileNotFoundError: If the source file could not be found.\n    \"\"\"\n    try:\n        from rio_cogeo.cogeo import cog_translate\n        from rio_cogeo.profiles import cog_profiles\n\n    except ImportError:\n        raise ImportError(\n            \"The rio-cogeo package is not installed. Please install it with `pip install rio-cogeo` or `conda install rio-cogeo -c conda-forge`.\"\n        )\n\n    if not source.startswith(\"http\"):\n        source = check_file_path(source)\n\n        if not os.path.exists(source):\n            raise FileNotFoundError(\"The provided input file could not be found.\")\n\n    if dst_path is None:\n        if not source.startswith(\"http\"):\n            dst_path = os.path.splitext(source)[0] + \"_cog.tif\"\n        else:\n            dst_path = temp_file_path(extension=\".tif\")\n\n    dst_path = check_file_path(dst_path)\n\n    dst_profile = cog_profiles.get(profile)\n    cog_translate(source, dst_path, dst_profile, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.random_string","title":"<code>random_string(string_length=6)</code>","text":"<p>Generates a random string of fixed length.</p> <p>Parameters:</p> Name Type Description Default <code>string_length</code> <code>int</code> <p>Fixed length. Defaults to 3.</p> <code>6</code> <p>Returns:</p> Type Description <code>str</code> <p>A random string</p> Source code in <code>samgeo/common.py</code> <pre><code>def random_string(string_length=6):\n\"\"\"Generates a random string of fixed length.\n\n    Args:\n        string_length (int, optional): Fixed length. Defaults to 3.\n\n    Returns:\n        str: A random string\n    \"\"\"\n    import random\n    import string\n\n    # random.seed(1001)\n    letters = string.ascii_lowercase\n    return \"\".join(random.choice(letters) for i in range(string_length))\n</code></pre>"},{"location":"common/#samgeo.common.raster_to_geojson","title":"<code>raster_to_geojson(tiff_path, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Convert a tiff file to a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>tiff_path</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the GeoJSON file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/common.py</code> <pre><code>def raster_to_geojson(tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a GeoJSON file.\n\n    Args:\n        tiff_path (str): The path to the tiff file.\n        output (str): The path to the GeoJSON file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n\n    if not output.endswith(\".geojson\"):\n        output += \".geojson\"\n\n    raster_to_vector(tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.raster_to_gpkg","title":"<code>raster_to_gpkg(tiff_path, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Convert a tiff file to a gpkg file.</p> <p>Parameters:</p> Name Type Description Default <code>tiff_path</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the gpkg file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/common.py</code> <pre><code>def raster_to_gpkg(tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a gpkg file.\n\n    Args:\n        tiff_path (str): The path to the tiff file.\n        output (str): The path to the gpkg file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n\n    if not output.endswith(\".gpkg\"):\n        output += \".gpkg\"\n\n    raster_to_vector(tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.raster_to_shp","title":"<code>raster_to_shp(tiff_path, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Convert a tiff file to a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>tiff_path</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the shapefile.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/common.py</code> <pre><code>def raster_to_shp(tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a shapefile.\n\n    Args:\n        tiff_path (str): The path to the tiff file.\n        output (str): The path to the shapefile.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n\n    if not output.endswith(\".shp\"):\n        output += \".shp\"\n\n    raster_to_vector(tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.raster_to_vector","title":"<code>raster_to_vector(source, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Vectorize a raster dataset.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the vector file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/common.py</code> <pre><code>def raster_to_vector(source, output, simplify_tolerance=None, **kwargs):\n\"\"\"Vectorize a raster dataset.\n\n    Args:\n        source (str): The path to the tiff file.\n        output (str): The path to the vector file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n    from rasterio import features\n\n    with rasterio.open(source) as src:\n        band = src.read()\n\n        mask = band != 0\n        shapes = features.shapes(band, mask=mask, transform=src.transform)\n\n    fc = [\n        {\"geometry\": shapely.geometry.shape(shape), \"properties\": {\"value\": value}}\n        for shape, value in shapes\n    ]\n    if simplify_tolerance is not None:\n        for i in fc:\n            i[\"geometry\"] = i[\"geometry\"].simplify(tolerance=simplify_tolerance)\n\n    gdf = gpd.GeoDataFrame.from_features(fc)\n    if src.crs is not None:\n        gdf.set_crs(crs=src.crs, inplace=True)\n    gdf.to_file(output, **kwargs)\n</code></pre>"},{"location":"common/#samgeo.common.reproject","title":"<code>reproject(image, output, dst_crs='EPSG:4326', resampling='nearest', to_cog=True, **kwargs)</code>","text":"<p>Reprojects an image.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The input image filepath.</p> required <code>output</code> <code>str</code> <p>The output image filepath.</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS. Defaults to \"EPSG:4326\".</p> <code>'EPSG:4326'</code> <code>resampling</code> <code>Resampling</code> <p>The resampling method. Defaults to \"nearest\".</p> <code>'nearest'</code> <code>to_cog</code> <code>bool</code> <p>Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to rasterio.open.</p> <code>{}</code> Source code in <code>samgeo/common.py</code> <pre><code>def reproject(\n    image, output, dst_crs=\"EPSG:4326\", resampling=\"nearest\", to_cog=True, **kwargs\n):\n\"\"\"Reprojects an image.\n\n    Args:\n        image (str): The input image filepath.\n        output (str): The output image filepath.\n        dst_crs (str, optional): The destination CRS. Defaults to \"EPSG:4326\".\n        resampling (Resampling, optional): The resampling method. Defaults to \"nearest\".\n        to_cog (bool, optional): Whether to convert the output image to a Cloud Optimized GeoTIFF. Defaults to True.\n        **kwargs: Additional keyword arguments to pass to rasterio.open.\n\n    \"\"\"\n    import rasterio as rio\n    from rasterio.warp import calculate_default_transform, reproject, Resampling\n\n    if isinstance(resampling, str):\n        resampling = getattr(Resampling, resampling)\n\n    image = os.path.abspath(image)\n    output = os.path.abspath(output)\n\n    if not os.path.exists(os.path.dirname(output)):\n        os.makedirs(os.path.dirname(output))\n\n    with rio.open(image, **kwargs) as src:\n        transform, width, height = calculate_default_transform(\n            src.crs, dst_crs, src.width, src.height, *src.bounds\n        )\n        kwargs = src.meta.copy()\n        kwargs.update(\n            {\n                \"crs\": dst_crs,\n                \"transform\": transform,\n                \"width\": width,\n                \"height\": height,\n            }\n        )\n\n        with rio.open(output, \"w\", **kwargs) as dst:\n            for i in range(1, src.count + 1):\n                reproject(\n                    source=rio.band(src, i),\n                    destination=rio.band(dst, i),\n                    src_transform=src.transform,\n                    src_crs=src.crs,\n                    dst_transform=transform,\n                    dst_crs=dst_crs,\n                    resampling=resampling,\n                    **kwargs,\n                )\n\n    if to_cog:\n        image_to_cog(output, output)\n</code></pre>"},{"location":"common/#samgeo.common.temp_file_path","title":"<code>temp_file_path(extension)</code>","text":"<p>Returns a temporary file path.</p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The file extension.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The temporary file path.</p> Source code in <code>samgeo/common.py</code> <pre><code>def temp_file_path(extension):\n\"\"\"Returns a temporary file path.\n\n    Args:\n        extension (str): The file extension.\n\n    Returns:\n        str: The temporary file path.\n    \"\"\"\n\n    import tempfile\n    import uuid\n\n    if not extension.startswith(\".\"):\n        extension = \".\" + extension\n    file_id = str(uuid.uuid4())\n    file_path = os.path.join(tempfile.gettempdir(), f\"{file_id}{extension}\")\n\n    return file_path\n</code></pre>"},{"location":"common/#samgeo.common.tms_to_geotiff","title":"<code>tms_to_geotiff(output, bbox, zoom=None, resolution=None, source='OpenStreetMap', crs='EPSG:3857', to_cog=False, return_image=False, overwrite=False, quiet=False, **kwargs)</code>","text":"<p>Download TMS tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.     Credits to the GitHub user @gumblex.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The output GeoTIFF file.</p> required <code>bbox</code> <code>list</code> <p>The bounding box [minx, miny, maxx, maxy], e.g., [-122.5216, 37.733, -122.3661, 37.8095]</p> required <code>zoom</code> <code>int</code> <p>The map zoom level. Defaults to None.</p> <code>None</code> <code>resolution</code> <code>float</code> <p>The resolution in meters. Defaults to None.</p> <code>None</code> <code>source</code> <code>str</code> <p>The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".</p> <code>'OpenStreetMap'</code> <code>crs</code> <code>str</code> <p>The output CRS. Defaults to \"EPSG:3857\".</p> <code>'EPSG:3857'</code> <code>to_cog</code> <code>bool</code> <p>Convert to Cloud Optimized GeoTIFF. Defaults to False.</p> <code>False</code> <code>return_image</code> <code>bool</code> <p>Return the image as PIL.Image. Defaults to False.</p> <code>False</code> <code>overwrite</code> <code>bool</code> <p>Overwrite the output file if it already exists. Defaults to False.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Suppress output. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().</p> <code>{}</code> Source code in <code>samgeo/common.py</code> <pre><code>def tms_to_geotiff(\n    output,\n    bbox,\n    zoom=None,\n    resolution=None,\n    source=\"OpenStreetMap\",\n    crs=\"EPSG:3857\",\n    to_cog=False,\n    return_image=False,\n    overwrite=False,\n    quiet=False,\n    **kwargs,\n):\n\"\"\"Download TMS tiles and convert them to a GeoTIFF. The source is adapted from https://github.com/gumblex/tms2geotiff.\n        Credits to the GitHub user @gumblex.\n\n    Args:\n        output (str): The output GeoTIFF file.\n        bbox (list): The bounding box [minx, miny, maxx, maxy], e.g., [-122.5216, 37.733, -122.3661, 37.8095]\n        zoom (int, optional): The map zoom level. Defaults to None.\n        resolution (float, optional): The resolution in meters. Defaults to None.\n        source (str, optional): The tile source. It can be one of the following: \"OPENSTREETMAP\", \"ROADMAP\",\n            \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or an HTTP URL. Defaults to \"OpenStreetMap\".\n        crs (str, optional): The output CRS. Defaults to \"EPSG:3857\".\n        to_cog (bool, optional): Convert to Cloud Optimized GeoTIFF. Defaults to False.\n        return_image (bool, optional): Return the image as PIL.Image. Defaults to False.\n        overwrite (bool, optional): Overwrite the output file if it already exists. Defaults to False.\n        quiet (bool, optional): Suppress output. Defaults to False.\n        **kwargs: Additional arguments to pass to gdal.GetDriverByName(\"GTiff\").Create().\n\n    \"\"\"\n\n    import os\n    import io\n    import math\n    import itertools\n    import concurrent.futures\n\n    import numpy\n    from PIL import Image\n\n    try:\n        from osgeo import gdal, osr\n    except ImportError:\n        raise ImportError(\"GDAL is not installed. Install it with pip install GDAL\")\n\n    try:\n        import httpx\n\n        SESSION = httpx.Client()\n    except ImportError:\n        import requests\n\n        SESSION = requests.Session()\n\n    if not overwrite and os.path.exists(output):\n        print(\n            f\"The output file {output} already exists. Use `overwrite=True` to overwrite it.\"\n        )\n        return\n\n    xyz_tiles = {\n        \"OPENSTREETMAP\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        \"ROADMAP\": \"https://mt1.google.com/vt/lyrs=m&amp;x={x}&amp;y={y}&amp;z={z}\",\n        \"SATELLITE\": \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n        \"TERRAIN\": \"https://mt1.google.com/vt/lyrs=p&amp;x={x}&amp;y={y}&amp;z={z}\",\n        \"HYBRID\": \"https://mt1.google.com/vt/lyrs=y&amp;x={x}&amp;y={y}&amp;z={z}\",\n    }\n\n    basemaps = get_basemaps()\n\n    if isinstance(source, str):\n        if source.upper() in xyz_tiles:\n            source = xyz_tiles[source.upper()]\n        elif source in basemaps:\n            source = basemaps[source]\n        elif source.startswith(\"http\"):\n            pass\n    else:\n        raise ValueError(\n            'source must be one of \"OpenStreetMap\", \"ROADMAP\", \"SATELLITE\", \"TERRAIN\", \"HYBRID\", or a URL'\n        )\n\n    def resolution_to_zoom_level(resolution):\n\"\"\"\n        Convert map resolution in meters to zoom level for Web Mercator (EPSG:3857) tiles.\n        \"\"\"\n        # Web Mercator tile size in meters at zoom level 0\n        initial_resolution = 156543.03392804097\n\n        # Calculate the zoom level\n        zoom_level = math.log2(initial_resolution / resolution)\n\n        return int(zoom_level)\n\n    if isinstance(bbox, list) and len(bbox) == 4:\n        west, south, east, north = bbox\n    else:\n        raise ValueError(\n            \"bbox must be a list of 4 coordinates in the format of [xmin, ymin, xmax, ymax]\"\n        )\n\n    if zoom is None and resolution is None:\n        raise ValueError(\"Either zoom or resolution must be provided\")\n    elif zoom is not None and resolution is not None:\n        raise ValueError(\"Only one of zoom or resolution can be provided\")\n\n    if resolution is not None:\n        zoom = resolution_to_zoom_level(resolution)\n\n    EARTH_EQUATORIAL_RADIUS = 6378137.0\n\n    Image.MAX_IMAGE_PIXELS = None\n\n    gdal.UseExceptions()\n    web_mercator = osr.SpatialReference()\n    web_mercator.ImportFromEPSG(3857)\n\n    WKT_3857 = web_mercator.ExportToWkt()\n\n    def from4326_to3857(lat, lon):\n        xtile = math.radians(lon) * EARTH_EQUATORIAL_RADIUS\n        ytile = (\n            math.log(math.tan(math.radians(45 + lat / 2.0))) * EARTH_EQUATORIAL_RADIUS\n        )\n        return (xtile, ytile)\n\n    def deg2num(lat, lon, zoom):\n        lat_r = math.radians(lat)\n        n = 2**zoom\n        xtile = (lon + 180) / 360 * n\n        ytile = (1 - math.log(math.tan(lat_r) + 1 / math.cos(lat_r)) / math.pi) / 2 * n\n        return (xtile, ytile)\n\n    def is_empty(im):\n        extrema = im.getextrema()\n        if len(extrema) &gt;= 3:\n            if len(extrema) &gt; 3 and extrema[-1] == (0, 0):\n                return True\n            for ext in extrema[:3]:\n                if ext != (0, 0):\n                    return False\n            return True\n        else:\n            return extrema[0] == (0, 0)\n\n    def paste_tile(bigim, base_size, tile, corner_xy, bbox):\n        if tile is None:\n            return bigim\n        im = Image.open(io.BytesIO(tile))\n        mode = \"RGB\" if im.mode == \"RGB\" else \"RGBA\"\n        size = im.size\n        if bigim is None:\n            base_size[0] = size[0]\n            base_size[1] = size[1]\n            newim = Image.new(\n                mode, (size[0] * (bbox[2] - bbox[0]), size[1] * (bbox[3] - bbox[1]))\n            )\n        else:\n            newim = bigim\n\n        dx = abs(corner_xy[0] - bbox[0])\n        dy = abs(corner_xy[1] - bbox[1])\n        xy0 = (size[0] * dx, size[1] * dy)\n        if mode == \"RGB\":\n            newim.paste(im, xy0)\n        else:\n            if im.mode != mode:\n                im = im.convert(mode)\n            if not is_empty(im):\n                newim.paste(im, xy0)\n        im.close()\n        return newim\n\n    def finish_picture(bigim, base_size, bbox, x0, y0, x1, y1):\n        xfrac = x0 - bbox[0]\n        yfrac = y0 - bbox[1]\n        x2 = round(base_size[0] * xfrac)\n        y2 = round(base_size[1] * yfrac)\n        imgw = round(base_size[0] * (x1 - x0))\n        imgh = round(base_size[1] * (y1 - y0))\n        retim = bigim.crop((x2, y2, x2 + imgw, y2 + imgh))\n        if retim.mode == \"RGBA\" and retim.getextrema()[3] == (255, 255):\n            retim = retim.convert(\"RGB\")\n        bigim.close()\n        return retim\n\n    def get_tile(url):\n        retry = 3\n        while 1:\n            try:\n                r = SESSION.get(url, timeout=60)\n                break\n            except Exception:\n                retry -= 1\n                if not retry:\n                    raise\n        if r.status_code == 404:\n            return None\n        elif not r.content:\n            return None\n        r.raise_for_status()\n        return r.content\n\n    def draw_tile(\n        source, lat0, lon0, lat1, lon1, zoom, filename, quiet=False, **kwargs\n    ):\n        x0, y0 = deg2num(lat0, lon0, zoom)\n        x1, y1 = deg2num(lat1, lon1, zoom)\n        if x0 &gt; x1:\n            x0, x1 = x1, x0\n        if y0 &gt; y1:\n            y0, y1 = y1, y0\n        corners = tuple(\n            itertools.product(\n                range(math.floor(x0), math.ceil(x1)),\n                range(math.floor(y0), math.ceil(y1)),\n            )\n        )\n        totalnum = len(corners)\n        futures = []\n        with concurrent.futures.ThreadPoolExecutor(5) as executor:\n            for x, y in corners:\n                futures.append(\n                    executor.submit(get_tile, source.format(z=zoom, x=x, y=y))\n                )\n            bbox = (math.floor(x0), math.floor(y0), math.ceil(x1), math.ceil(y1))\n            bigim = None\n            base_size = [256, 256]\n            for k, (fut, corner_xy) in enumerate(zip(futures, corners), 1):\n                bigim = paste_tile(bigim, base_size, fut.result(), corner_xy, bbox)\n                if not quiet:\n                    print(\n                        f\"Downloaded image {str(k).zfill(len(str(totalnum)))}/{totalnum}\"\n                    )\n\n        if not quiet:\n            print(\"Saving GeoTIFF. Please wait...\")\n        img = finish_picture(bigim, base_size, bbox, x0, y0, x1, y1)\n        imgbands = len(img.getbands())\n        driver = gdal.GetDriverByName(\"GTiff\")\n\n        if \"options\" not in kwargs:\n            kwargs[\"options\"] = [\n                \"COMPRESS=DEFLATE\",\n                \"PREDICTOR=2\",\n                \"ZLEVEL=9\",\n                \"TILED=YES\",\n            ]\n\n        gtiff = driver.Create(\n            filename,\n            img.size[0],\n            img.size[1],\n            imgbands,\n            gdal.GDT_Byte,\n            **kwargs,\n        )\n        xp0, yp0 = from4326_to3857(lat0, lon0)\n        xp1, yp1 = from4326_to3857(lat1, lon1)\n        pwidth = abs(xp1 - xp0) / img.size[0]\n        pheight = abs(yp1 - yp0) / img.size[1]\n        gtiff.SetGeoTransform((min(xp0, xp1), pwidth, 0, max(yp0, yp1), 0, -pheight))\n        gtiff.SetProjection(WKT_3857)\n        for band in range(imgbands):\n            array = numpy.array(img.getdata(band), dtype=\"u8\")\n            array = array.reshape((img.size[1], img.size[0]))\n            band = gtiff.GetRasterBand(band + 1)\n            band.WriteArray(array)\n        gtiff.FlushCache()\n\n        if not quiet:\n            print(f\"Image saved to {filename}\")\n        return img\n\n    try:\n        image = draw_tile(\n            source, south, west, north, east, zoom, output, quiet, **kwargs\n        )\n        if return_image:\n            return image\n        if crs.upper() != \"EPSG:3857\":\n            reproject(output, output, crs, to_cog=to_cog)\n        elif to_cog:\n            image_to_cog(output, output)\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#samgeo.common.transform_coords","title":"<code>transform_coords(x, y, src_crs, dst_crs, **kwargs)</code>","text":"<p>Transform coordinates from one CRS to another.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>The x coordinate.</p> required <code>y</code> <code>float</code> <p>The y coordinate.</p> required <code>src_crs</code> <code>str</code> <p>The source CRS, e.g., \"EPSG:4326\".</p> required <code>dst_crs</code> <code>str</code> <p>The destination CRS, e.g., \"EPSG:3857\".</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The transformed coordinates in the format of (x, y)</p> Source code in <code>samgeo/common.py</code> <pre><code>def transform_coords(x, y, src_crs, dst_crs, **kwargs):\n\"\"\"Transform coordinates from one CRS to another.\n\n    Args:\n        x (float): The x coordinate.\n        y (float): The y coordinate.\n        src_crs (str): The source CRS, e.g., \"EPSG:4326\".\n        dst_crs (str): The destination CRS, e.g., \"EPSG:3857\".\n\n    Returns:\n        dict: The transformed coordinates in the format of (x, y)\n    \"\"\"\n    transformer = pyproj.Transformer.from_crs(\n        src_crs, dst_crs, always_xy=True, **kwargs\n    )\n    return transformer.transform(x, y)\n</code></pre>"},{"location":"common/#samgeo.common.update_package","title":"<code>update_package(out_dir=None, keep=False, **kwargs)</code>","text":"<p>Updates the package from the GitHub repository without the need to use pip or conda.</p> <p>Parameters:</p> Name Type Description Default <code>out_dir</code> <code>str</code> <p>The output directory. Defaults to None.</p> <code>None</code> <code>keep</code> <code>bool</code> <p>Whether to keep the downloaded package. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the download_file() function.</p> <code>{}</code> Source code in <code>samgeo/common.py</code> <pre><code>def update_package(out_dir=None, keep=False, **kwargs):\n\"\"\"Updates the package from the GitHub repository without the need to use pip or conda.\n\n    Args:\n        out_dir (str, optional): The output directory. Defaults to None.\n        keep (bool, optional): Whether to keep the downloaded package. Defaults to False.\n        **kwargs: Additional keyword arguments to pass to the download_file() function.\n    \"\"\"\n\n    import shutil\n\n    try:\n        if out_dir is None:\n            out_dir = os.getcwd()\n        url = (\n            \"https://github.com/opengeos/segment-geospatial/archive/refs/heads/main.zip\"\n        )\n        filename = \"segment-geospatial-main.zip\"\n        download_file(url, filename, **kwargs)\n\n        pkg_dir = os.path.join(out_dir, \"segment-geospatial-main\")\n        work_dir = os.getcwd()\n        os.chdir(pkg_dir)\n\n        if shutil.which(\"pip\") is None:\n            cmd = \"pip3 install .\"\n        else:\n            cmd = \"pip install .\"\n\n        os.system(cmd)\n        os.chdir(work_dir)\n\n        if not keep:\n            shutil.rmtree(pkg_dir)\n            os.remove(filename)\n\n        print(\"Package updated successfully.\")\n\n    except Exception as e:\n        raise Exception(e)\n</code></pre>"},{"location":"common/#samgeo.common.vector_to_geojson","title":"<code>vector_to_geojson(filename, output=None, **kwargs)</code>","text":"<p>Converts a vector file to a geojson file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The vector file path.</p> required <code>output</code> <code>str</code> <p>The output geojson file path. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>The geojson dictionary.</p> Source code in <code>samgeo/common.py</code> <pre><code>def vector_to_geojson(filename, output=None, **kwargs):\n\"\"\"Converts a vector file to a geojson file.\n\n    Args:\n        filename (str): The vector file path.\n        output (str, optional): The output geojson file path. Defaults to None.\n\n    Returns:\n        dict: The geojson dictionary.\n    \"\"\"\n    gdf = gpd.read_file(filename, **kwargs)\n    if output is None:\n        return gdf.__geo_interface__\n    else:\n        gdf.to_file(output, driver=\"GeoJSON\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/giswqs/segment-geospatial/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>segment-geospatial could always use more documentation, whether as part of the official segment-geospatial docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/giswqs/segment-geospatial/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up segment-geospatial for local development.</p> <ol> <li> <p>Fork the segment-geospatial repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/segment-geospatial.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv segment-geospatial\n$ cd segment-geospatial/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 segment-geospatial tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy. Check https://github.com/giswqs/segment-geospatial/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>segment-geospatial is available on PyPI. To install segment-geospatial, run this command in your terminal:</p> <pre><code>pip install segment-geospatial\n</code></pre>"},{"location":"installation/#install-from-conda-forge","title":"Install from conda-forge","text":"<p>segment-geospatial is also available on conda-forge. If you have Anaconda or Miniconda installed on your computer, you can install segment-geospatial using the following command:</p> <pre><code>conda install -c conda-forge segment-geospatial\n</code></pre> <p>It is recommended to create a fresh conda environment for segment-geospatial. The following command will create a new conda environment named <code>geo</code> and install segment-geospatial and its dependencies:</p> <pre><code>conda install -n base mamba -c conda-forge\nmamba create -n geo segment-geospatial python -c conda-forge\n</code></pre>"},{"location":"installation/#install-from-github","title":"Install from GitHub","text":"<p>To install the development version from GitHub using Git, run the following command in your terminal:</p> <pre><code>pip install git+https://github.com/opengeos/segment-geospatial\n</code></pre>"},{"location":"samgeo/","title":"samgeo module","text":"<p>The source code is adapted from https://github.com/aliaksandr960/segment-anything-eo. Credit to the author Aliaksandr Hancharenka.</p>"},{"location":"samgeo/#samgeo.samgeo.SamGeo","title":"<code> SamGeo        </code>","text":"<p>The main class for segmenting geospatial data with the Segment Anything Model (SAM). See https://github.com/facebookresearch/segment-anything for details.</p> Source code in <code>samgeo/samgeo.py</code> <pre><code>class SamGeo:\n\"\"\"The main class for segmenting geospatial data with the Segment Anything Model (SAM). See\n    https://github.com/facebookresearch/segment-anything for details.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_type=\"vit_h\",\n        checkpoint=\"sam_vit_h_4b8939.pth\",\n        automatic=True,\n        device=None,\n        sam_kwargs=None,\n    ):\n\"\"\"Initialize the class.\n\n        Args:\n            model_type (str, optional): The model type. It can be one of the following: vit_h, vit_l, vit_b.\n                Defaults to 'vit_h'. See https://bit.ly/3VrpxUh for more details.\n            checkpoint (str, optional): The path to the model checkpoint. It can be one of the following:\n                sam_vit_h_4b8939.pth, sam_vit_l_0b3195.pth, sam_vit_b_01ec64.pth.\n                Defaults to \"sam_vit_h_4b8939.pth\". See https://bit.ly/3VrpxUh for more details.\n            automatic (bool, optional): Whether to use the automatic mask generator or input prompts. Defaults to True.\n                The automatic mask generator will segment the entire image, while the input prompts will segment selected objects.\n            device (str, optional): The device to use. It can be one of the following: cpu, cuda.\n                Defaults to None, which will use cuda if available.\n            sam_kwargs (dict, optional): Optional arguments for fine-tuning the SAM model. Defaults to None.\n                The available arguments with default values are listed below. See https://bit.ly/410RV0v for more details.\n\n                points_per_side: Optional[int] = 32,\n                points_per_batch: int = 64,\n                pred_iou_thresh: float = 0.88,\n                stability_score_thresh: float = 0.95,\n                stability_score_offset: float = 1.0,\n                box_nms_thresh: float = 0.7,\n                crop_n_layers: int = 0,\n                crop_nms_thresh: float = 0.7,\n                crop_overlap_ratio: float = 512 / 1500,\n                crop_n_points_downscale_factor: int = 1,\n                point_grids: Optional[List[np.ndarray]] = None,\n                min_mask_region_area: int = 0,\n                output_mode: str = \"binary_mask\",\n\n        \"\"\"\n        # Download the checkpoint if it does not exist\n        if not os.path.exists(checkpoint):\n            print(f\"Checkpoint {checkpoint} does not exist.\")\n            download_checkpoint(output=checkpoint)\n\n        # Use cuda if available\n        if device is None:\n            device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n            if device == \"cuda\":\n                torch.cuda.empty_cache()\n\n        self.checkpoint = checkpoint\n        self.model_type = model_type\n        self.device = device\n        self.sam_kwargs = sam_kwargs  # Optional arguments for fine-tuning the SAM model\n        self.source = None  # Store the input image path\n        self.image = None  # Store the input image as a numpy array\n        # Store the masks as a list of dictionaries. Each mask is a dictionary\n        # containing segmentation, area, bbox, predicted_iou, point_coords, stability_score, and crop_box\n        self.masks = None\n        self.objects = None  # Store the mask objects as a numpy array\n        # Store the annotations (objects with random color) as a numpy array.\n        self.annotations = None\n\n        # Store the predicted masks, iou_predictions, and low_res_masks\n        self.prediction = None\n        self.scores = None\n        self.logits = None\n\n        # Build the SAM model\n        self.sam = sam_model_registry[self.model_type](checkpoint=self.checkpoint)\n        self.sam.to(device=self.device)\n        # Use optional arguments for fine-tuning the SAM model\n        sam_kwargs = self.sam_kwargs if self.sam_kwargs is not None else {}\n\n        if automatic:\n            # Segment the entire image using the automatic mask generator\n            self.mask_generator = SamAutomaticMaskGenerator(self.sam, **sam_kwargs)\n        else:\n            # Segment selected objects using input prompts\n            self.predictor = SamPredictor(self.sam, **sam_kwargs)\n\n    def __call__(\n        self,\n        image,\n        foreground=True,\n        erosion_kernel=(3, 3),\n        mask_multiplier=255,\n        **kwargs,\n    ):\n\"\"\"Generate masks for the input tile. This function originates from the segment-anything-eo repository.\n            See https://bit.ly/41pwiHw\n\n        Args:\n            image (np.ndarray): The input image as a numpy array.\n            foreground (bool, optional): Whether to generate the foreground mask. Defaults to True.\n            erosion_kernel (tuple, optional): The erosion kernel for filtering object masks and extract borders. Defaults to (3, 3).\n            mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n                You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.\n        \"\"\"\n        h, w, _ = image.shape\n\n        masks = self.mask_generator.generate(image)\n\n        if foreground:  # Extract foreground objects only\n            resulting_mask = np.zeros((h, w), dtype=np.uint8)\n        else:\n            resulting_mask = np.ones((h, w), dtype=np.uint8)\n        resulting_borders = np.zeros((h, w), dtype=np.uint8)\n\n        for m in masks:\n            mask = (m[\"segmentation\"] &gt; 0).astype(np.uint8)\n            resulting_mask += mask\n\n            # Apply erosion to the mask\n            if erosion_kernel is not None:\n                mask_erode = cv2.erode(mask, erosion_kernel, iterations=1)\n                mask_erode = (mask_erode &gt; 0).astype(np.uint8)\n                edge_mask = mask - mask_erode\n                resulting_borders += edge_mask\n\n        resulting_mask = (resulting_mask &gt; 0).astype(np.uint8)\n        resulting_borders = (resulting_borders &gt; 0).astype(np.uint8)\n        resulting_mask_with_borders = resulting_mask - resulting_borders\n        return resulting_mask_with_borders * mask_multiplier\n\n    def generate(\n        self,\n        source,\n        output=None,\n        foreground=True,\n        batch=False,\n        erosion_kernel=None,\n        mask_multiplier=255,\n        unique=True,\n        **kwargs,\n    ):\n\"\"\"Generate masks for the input image.\n\n        Args:\n            source (str | np.ndarray): The path to the input image or the input image as a numpy array.\n            output (str, optional): The path to the output image. Defaults to None.\n            foreground (bool, optional): Whether to generate the foreground mask. Defaults to True.\n            batch (bool, optional): Whether to generate masks for a batch of image tiles. Defaults to False.\n            erosion_kernel (tuple, optional): The erosion kernel for filtering object masks and extract borders.\n                Such as (3, 3) or (5, 5). Set to None to disable it. Defaults to None.\n            mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n                You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.\n                The parameter is ignored if unique is True.\n            unique (bool, optional): Whether to assign a unique value to each object. Defaults to True.\n                The unique value increases from 1 to the number of objects. The larger the number, the larger the object area.\n\n        \"\"\"\n\n        if isinstance(source, str):\n            if source.startswith(\"http\"):\n                source = download_file(source)\n\n            if not os.path.exists(source):\n                raise ValueError(f\"Input path {source} does not exist.\")\n\n            if batch:  # Subdivide the image into tiles and segment each tile\n                return tiff_to_tiff(\n                    source,\n                    output,\n                    self,\n                    foreground=foreground,\n                    erosion_kernel=erosion_kernel,\n                    mask_multiplier=mask_multiplier,\n                    **kwargs,\n                )\n\n            image = cv2.imread(source)\n        elif isinstance(source, np.ndarray):\n            image = source\n        else:\n            raise ValueError(\"Input source must be either a path or a numpy array.\")\n\n        self.source = source  # Store the input image path\n        self.image = image  # Store the input image as a numpy array\n        mask_generator = self.mask_generator  # The automatic mask generator\n        masks = mask_generator.generate(image)  # Segment the input image\n        self.masks = masks  # Store the masks as a list of dictionaries\n\n        if output is not None:\n            # Save the masks to the output path. The output is either a binary mask or a mask of objects with unique values.\n            self.save_masks(\n                output, foreground, unique, erosion_kernel, mask_multiplier, **kwargs\n            )\n\n    def save_masks(\n        self,\n        output=None,\n        foreground=True,\n        unique=True,\n        erosion_kernel=None,\n        mask_multiplier=255,\n        **kwargs,\n    ):\n\"\"\"Save the masks to the output path. The output is either a binary mask or a mask of objects with unique values.\n\n        Args:\n            output (str, optional): The path to the output image. Defaults to None, saving the masks to SamGeo.objects.\n            foreground (bool, optional): Whether to generate the foreground mask. Defaults to True.\n            unique (bool, optional): Whether to assign a unique value to each object. Defaults to True.\n            erosion_kernel (tuple, optional): The erosion kernel for filtering object masks and extract borders.\n                Such as (3, 3) or (5, 5). Set to None to disable it. Defaults to None.\n            mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n                You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.\n\n        \"\"\"\n\n        if self.masks is None:\n            raise ValueError(\"No masks found. Please run generate() first.\")\n\n        h, w, _ = self.image.shape\n        masks = self.masks\n\n        # Set output image data type based on the number of objects\n        if len(masks) &lt; 255:\n            dtype = np.uint8\n        elif len(masks) &lt; 65535:\n            dtype = np.uint16\n        else:\n            dtype = np.uint32\n\n        # Generate a mask of objects with unique values\n        if unique:\n            # Sort the masks by area in ascending order\n            sorted_masks = sorted(masks, key=(lambda x: x[\"area\"]), reverse=False)\n\n            # Create an output image with the same size as the input image\n            objects = np.zeros(\n                (\n                    sorted_masks[0][\"segmentation\"].shape[0],\n                    sorted_masks[0][\"segmentation\"].shape[1],\n                )\n            )\n            # Assign a unique value to each object\n            for index, ann in enumerate(sorted_masks):\n                m = ann[\"segmentation\"]\n                objects[m] = index + 1\n\n        # Generate a binary mask\n        else:\n            if foreground:  # Extract foreground objects only\n                resulting_mask = np.zeros((h, w), dtype=dtype)\n            else:\n                resulting_mask = np.ones((h, w), dtype=dtype)\n            resulting_borders = np.zeros((h, w), dtype=dtype)\n\n            for m in masks:\n                mask = (m[\"segmentation\"] &gt; 0).astype(dtype)\n                resulting_mask += mask\n\n                # Apply erosion to the mask\n                if erosion_kernel is not None:\n                    mask_erode = cv2.erode(mask, erosion_kernel, iterations=1)\n                    mask_erode = (mask_erode &gt; 0).astype(dtype)\n                    edge_mask = mask - mask_erode\n                    resulting_borders += edge_mask\n\n            resulting_mask = (resulting_mask &gt; 0).astype(dtype)\n            resulting_borders = (resulting_borders &gt; 0).astype(dtype)\n            objects = resulting_mask - resulting_borders\n            objects = objects * mask_multiplier\n\n        objects = objects.astype(dtype)\n        self.objects = objects\n\n        if output is not None:  # Save the output image\n            array_to_image(self.objects, output, self.source, **kwargs)\n\n    def show_masks(\n        self, figsize=(12, 10), cmap=\"binary_r\", axis=\"off\", foreground=True, **kwargs\n    ):\n\"\"\"Show the binary mask or the mask of objects with unique values.\n\n        Args:\n            figsize (tuple, optional): The figure size. Defaults to (12, 10).\n            cmap (str, optional): The colormap. Defaults to \"binary_r\".\n            axis (str, optional): Whether to show the axis. Defaults to \"off\".\n            foreground (bool, optional): Whether to show the foreground mask only. Defaults to True.\n            **kwargs: Other arguments for save_masks().\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n\n        if self.objects is None:\n            self.save_masks(foreground=foreground, **kwargs)\n\n        plt.figure(figsize=figsize)\n        plt.imshow(self.objects, cmap=cmap)\n        plt.axis(axis)\n        plt.show()\n\n    def show_anns(\n        self, figsize=(12, 10), axis=\"off\", alpha=0.35, output=None, **kwargs\n    ):\n\"\"\"Show the annotations (objects with random color) on the input image.\n\n        Args:\n            figsize (tuple, optional): The figure size. Defaults to (12, 10).\n            axis (str, optional): Whether to show the axis. Defaults to \"off\".\n            alpha (float, optional): The alpha value for the annotations. Defaults to 0.35.\n            output (str, optional): The path to the output image. Defaults to None.\n        \"\"\"\n\n        import matplotlib.pyplot as plt\n\n        anns = self.masks\n\n        if self.image is None:\n            print(\"Please run generate() first.\")\n            return\n\n        if anns is None or len(anns) == 0:\n            return\n\n        plt.figure(figsize=figsize)\n        plt.imshow(self.image)\n\n        sorted_anns = sorted(anns, key=(lambda x: x[\"area\"]), reverse=True)\n\n        ax = plt.gca()\n        ax.set_autoscale_on(False)\n\n        img = np.ones(\n            (\n                sorted_anns[0][\"segmentation\"].shape[0],\n                sorted_anns[0][\"segmentation\"].shape[1],\n                4,\n            )\n        )\n        img[:, :, 3] = 0\n        for ann in sorted_anns:\n            m = ann[\"segmentation\"]\n            color_mask = np.concatenate([np.random.random(3), [alpha]])\n            img[m] = color_mask\n        ax.imshow(img)\n\n        if \"dpi\" not in kwargs:\n            kwargs[\"dpi\"] = 100\n\n        if \"bbox_inches\" not in kwargs:\n            kwargs[\"bbox_inches\"] = \"tight\"\n\n        plt.axis(axis)\n\n        self.annotations = (img[:, :, 0:3] * 255).astype(np.uint8)\n\n        if output is not None:\n            array = blend_images(self.annotations, self.image, alpha=alpha, show=False)\n            array_to_image(array, output, self.source)\n\n    def set_image(self, image, image_format=\"RGB\"):\n\"\"\"Set the input image as a numpy array.\n\n        Args:\n            image (np.ndarray): The input image as a numpy array.\n            image_format (str, optional): The image format, can be RGB or BGR. Defaults to \"RGB\".\n        \"\"\"\n        if isinstance(image, str):\n            if image.startswith(\"http\"):\n                image = download_file(image)\n\n            if not os.path.exists(image):\n                raise ValueError(f\"Input path {image} does not exist.\")\n\n            self.image = image\n\n            image = cv2.imread(image)\n            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        elif isinstance(image, np.ndarray):\n            pass\n        else:\n            raise ValueError(\"Input image must be either a path or a numpy array.\")\n\n        self.predictor.set_image(image, image_format=image_format)\n\n    def save_prediction(\n        self,\n        output,\n        index=None,\n        mask_multiplier=255,\n        dtype=np.float32,\n        vector=None,\n        simplify_tolerance=None,\n        **kwargs,\n    ):\n\"\"\"Save the predicted mask to the output path.\n\n        Args:\n            output (str): The path to the output image.\n            index (int, optional): The index of the mask to save. Defaults to None,\n                which will save the mask with the highest score.\n            mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n            vector (str, optional): The path to the output vector file. Defaults to None.\n            dtype (np.dtype, optional): The data type of the output image. Defaults to np.float32.\n            simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n                The higher this value, the smaller the number of vertices in the resulting geometry.\n\n        \"\"\"\n        if self.scores is None:\n            raise ValueError(\"No predictions found. Please run predict() first.\")\n\n        if index is None:\n            index = self.scores.argmax(axis=0)\n\n        array = self.masks[index] * mask_multiplier\n        self.prediction = array\n        array_to_image(array, output, self.image, dtype=dtype, **kwargs)\n\n        if vector is not None:\n            raster_to_vector(output, vector, simplify_tolerance=simplify_tolerance)\n\n    def predict(\n        self,\n        point_coords=None,\n        point_labels=None,\n        box=None,\n        point_crs=None,\n        mask_input=None,\n        multimask_output=True,\n        return_logits=False,\n        output=None,\n        index=None,\n        mask_multiplier=255,\n        dtype=np.float32,\n        return_results=False,\n        **kwargs,\n    ):\n\"\"\"Predict masks for the given input prompts, using the currently set image.\n\n        Args:\n            point_coords (str | dict | list | np.ndarray, optional): A Nx2 array of point prompts to the\n                model. Each point is in (X,Y) in pixels. It can be a path to a vector file, a GeoJSON\n                dictionary, a list of coordinates [lon, lat], or a numpy array. Defaults to None.\n            point_labels (list | int | np.ndarray, optional): A length N array of labels for the\n                point prompts. 1 indicates a foreground point and 0 indicates a background point.\n            point_crs (str, optional): The coordinate reference system (CRS) of the point prompts.\n            box (list | np.ndarray, optional): A length 4 array given a box prompt to the\n                model, in XYXY format.\n            mask_input (np.ndarray, optional): A low resolution mask input to the model, typically\n                coming from a previous prediction iteration. Has form 1xHxW, where for SAM, H=W=256.\n                multimask_output (bool, optional): If true, the model will return three masks.\n                For ambiguous input prompts (such as a single click), this will often\n                produce better masks than a single prediction. If only a single\n                mask is needed, the model's predicted quality score can be used\n                to select the best mask. For non-ambiguous prompts, such as multiple\n                input prompts, multimask_output=False can give better results.\n            return_logits (bool, optional): If true, returns un-thresholded masks logits\n                instead of a binary mask.\n            output (str, optional): The path to the output image. Defaults to None.\n            index (index, optional): The index of the mask to save. Defaults to None,\n                which will save the mask with the highest score.\n            mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n            dtype (np.dtype, optional): The data type of the output image. Defaults to np.float32.\n            return_results (bool, optional): Whether to return the predicted masks, scores, and logits. Defaults to False.\n\n        \"\"\"\n\n        if isinstance(point_coords, str):\n            point_coords = vector_to_geojson(point_coords)\n\n        if isinstance(point_coords, dict):\n            point_coords = geojson_to_coords(point_coords)\n\n        if point_crs is not None:\n            point_coords = coords_to_xy(self.image, point_coords, point_crs)\n\n        if isinstance(point_coords, list):\n            point_coords = np.array(point_coords)\n\n        if point_labels is None:\n            point_labels = [1] * len(point_coords)\n        elif isinstance(point_labels, int):\n            point_labels = [point_labels] * len(point_coords)\n\n        if isinstance(point_labels, list):\n            if len(point_labels) != len(point_coords):\n                if len(point_labels) == 1:\n                    point_labels = point_labels * len(point_coords)\n                else:\n                    raise ValueError(\n                        \"The length of point_labels must be equal to the length of point_coords.\"\n                    )\n            point_labels = np.array(point_labels)\n\n        if isinstance(box, list) and point_crs is not None:\n            box = np.array(bbox_to_xy(self.image, box, point_crs))\n\n        predictor = self.predictor\n        masks, scores, logits = predictor.predict(\n            point_coords, point_labels, box, mask_input, multimask_output, return_logits\n        )\n        self.masks = masks\n        self.scores = scores\n        self.logits = logits\n\n        if output is not None:\n            self.save_prediction(output, index, mask_multiplier, dtype, **kwargs)\n\n        if return_results:\n            return masks, scores, logits\n\n    def show_map(self, **kwargs):\n        return sam_map_gui(self, **kwargs)\n\n    def image_to_image(self, image, **kwargs):\n        return image_to_image(image, self, **kwargs)\n\n    def download_tms_as_tiff(self, source, pt1, pt2, zoom, dist):\n        image = draw_tile(source, pt1[0], pt1[1], pt2[0], pt2[1], zoom, dist)\n        return image\n\n    def tiff_to_vector(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a gpkg file.\n\n        Args:\n            tiff_path (str): The path to the tiff file.\n            output (str): The path to the vector file.\n            simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n                The higher this value, the smaller the number of vertices in the resulting geometry.\n        \"\"\"\n\n        raster_to_vector(\n            tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n        )\n\n    def tiff_to_gpkg(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a gpkg file.\n\n        Args:\n            tiff_path (str): The path to the tiff file.\n            output (str): The path to the gpkg file.\n            simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n                The higher this value, the smaller the number of vertices in the resulting geometry.\n        \"\"\"\n\n        raster_to_gpkg(\n            tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n        )\n\n    def tiff_to_shp(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a shapefile.\n\n        Args:\n            tiff_path (str): The path to the tiff file.\n            output (str): The path to the shapefile.\n            simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n                The higher this value, the smaller the number of vertices in the resulting geometry.\n        \"\"\"\n\n        raster_to_shp(\n            tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n        )\n\n    def tiff_to_geojson(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a GeoJSON file.\n\n        Args:\n            tiff_path (str): The path to the tiff file.\n            output (str): The path to the GeoJSON file.\n            simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n                The higher this value, the smaller the number of vertices in the resulting geometry.\n        \"\"\"\n\n        raster_to_geojson(\n            tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n        )\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.__call__","title":"<code>__call__(self, image, foreground=True, erosion_kernel=(3, 3), mask_multiplier=255, **kwargs)</code>  <code>special</code>","text":"<p>Generate masks for the input tile. This function originates from the segment-anything-eo repository.     See https://bit.ly/41pwiHw</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>The input image as a numpy array.</p> required <code>foreground</code> <code>bool</code> <p>Whether to generate the foreground mask. Defaults to True.</p> <code>True</code> <code>erosion_kernel</code> <code>tuple</code> <p>The erosion kernel for filtering object masks and extract borders. Defaults to (3, 3).</p> <code>(3, 3)</code> <code>mask_multiplier</code> <code>int</code> <p>The mask multiplier for the output mask, which is usually a binary mask [0, 1]. You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.</p> <code>255</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def __call__(\n    self,\n    image,\n    foreground=True,\n    erosion_kernel=(3, 3),\n    mask_multiplier=255,\n    **kwargs,\n):\n\"\"\"Generate masks for the input tile. This function originates from the segment-anything-eo repository.\n        See https://bit.ly/41pwiHw\n\n    Args:\n        image (np.ndarray): The input image as a numpy array.\n        foreground (bool, optional): Whether to generate the foreground mask. Defaults to True.\n        erosion_kernel (tuple, optional): The erosion kernel for filtering object masks and extract borders. Defaults to (3, 3).\n        mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n            You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.\n    \"\"\"\n    h, w, _ = image.shape\n\n    masks = self.mask_generator.generate(image)\n\n    if foreground:  # Extract foreground objects only\n        resulting_mask = np.zeros((h, w), dtype=np.uint8)\n    else:\n        resulting_mask = np.ones((h, w), dtype=np.uint8)\n    resulting_borders = np.zeros((h, w), dtype=np.uint8)\n\n    for m in masks:\n        mask = (m[\"segmentation\"] &gt; 0).astype(np.uint8)\n        resulting_mask += mask\n\n        # Apply erosion to the mask\n        if erosion_kernel is not None:\n            mask_erode = cv2.erode(mask, erosion_kernel, iterations=1)\n            mask_erode = (mask_erode &gt; 0).astype(np.uint8)\n            edge_mask = mask - mask_erode\n            resulting_borders += edge_mask\n\n    resulting_mask = (resulting_mask &gt; 0).astype(np.uint8)\n    resulting_borders = (resulting_borders &gt; 0).astype(np.uint8)\n    resulting_mask_with_borders = resulting_mask - resulting_borders\n    return resulting_mask_with_borders * mask_multiplier\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.__init__","title":"<code>__init__(self, model_type='vit_h', checkpoint='sam_vit_h_4b8939.pth', automatic=True, device=None, sam_kwargs=None)</code>  <code>special</code>","text":"<p>Initialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>model_type</code> <code>str</code> <p>The model type. It can be one of the following: vit_h, vit_l, vit_b. Defaults to 'vit_h'. See https://bit.ly/3VrpxUh for more details.</p> <code>'vit_h'</code> <code>checkpoint</code> <code>str</code> <p>The path to the model checkpoint. It can be one of the following: sam_vit_h_4b8939.pth, sam_vit_l_0b3195.pth, sam_vit_b_01ec64.pth. Defaults to \"sam_vit_h_4b8939.pth\". See https://bit.ly/3VrpxUh for more details.</p> <code>'sam_vit_h_4b8939.pth'</code> <code>automatic</code> <code>bool</code> <p>Whether to use the automatic mask generator or input prompts. Defaults to True. The automatic mask generator will segment the entire image, while the input prompts will segment selected objects.</p> <code>True</code> <code>device</code> <code>str</code> <p>The device to use. It can be one of the following: cpu, cuda. Defaults to None, which will use cuda if available.</p> <code>None</code> <code>sam_kwargs</code> <code>dict</code> <p>Optional arguments for fine-tuning the SAM model. Defaults to None. The available arguments with default values are listed below. See https://bit.ly/410RV0v for more details.</p> <p>points_per_side: Optional[int] = 32, points_per_batch: int = 64, pred_iou_thresh: float = 0.88, stability_score_thresh: float = 0.95, stability_score_offset: float = 1.0, box_nms_thresh: float = 0.7, crop_n_layers: int = 0, crop_nms_thresh: float = 0.7, crop_overlap_ratio: float = 512 / 1500, crop_n_points_downscale_factor: int = 1, point_grids: Optional[List[np.ndarray]] = None, min_mask_region_area: int = 0, output_mode: str = \"binary_mask\",</p> <code>None</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def __init__(\n    self,\n    model_type=\"vit_h\",\n    checkpoint=\"sam_vit_h_4b8939.pth\",\n    automatic=True,\n    device=None,\n    sam_kwargs=None,\n):\n\"\"\"Initialize the class.\n\n    Args:\n        model_type (str, optional): The model type. It can be one of the following: vit_h, vit_l, vit_b.\n            Defaults to 'vit_h'. See https://bit.ly/3VrpxUh for more details.\n        checkpoint (str, optional): The path to the model checkpoint. It can be one of the following:\n            sam_vit_h_4b8939.pth, sam_vit_l_0b3195.pth, sam_vit_b_01ec64.pth.\n            Defaults to \"sam_vit_h_4b8939.pth\". See https://bit.ly/3VrpxUh for more details.\n        automatic (bool, optional): Whether to use the automatic mask generator or input prompts. Defaults to True.\n            The automatic mask generator will segment the entire image, while the input prompts will segment selected objects.\n        device (str, optional): The device to use. It can be one of the following: cpu, cuda.\n            Defaults to None, which will use cuda if available.\n        sam_kwargs (dict, optional): Optional arguments for fine-tuning the SAM model. Defaults to None.\n            The available arguments with default values are listed below. See https://bit.ly/410RV0v for more details.\n\n            points_per_side: Optional[int] = 32,\n            points_per_batch: int = 64,\n            pred_iou_thresh: float = 0.88,\n            stability_score_thresh: float = 0.95,\n            stability_score_offset: float = 1.0,\n            box_nms_thresh: float = 0.7,\n            crop_n_layers: int = 0,\n            crop_nms_thresh: float = 0.7,\n            crop_overlap_ratio: float = 512 / 1500,\n            crop_n_points_downscale_factor: int = 1,\n            point_grids: Optional[List[np.ndarray]] = None,\n            min_mask_region_area: int = 0,\n            output_mode: str = \"binary_mask\",\n\n    \"\"\"\n    # Download the checkpoint if it does not exist\n    if not os.path.exists(checkpoint):\n        print(f\"Checkpoint {checkpoint} does not exist.\")\n        download_checkpoint(output=checkpoint)\n\n    # Use cuda if available\n    if device is None:\n        device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        if device == \"cuda\":\n            torch.cuda.empty_cache()\n\n    self.checkpoint = checkpoint\n    self.model_type = model_type\n    self.device = device\n    self.sam_kwargs = sam_kwargs  # Optional arguments for fine-tuning the SAM model\n    self.source = None  # Store the input image path\n    self.image = None  # Store the input image as a numpy array\n    # Store the masks as a list of dictionaries. Each mask is a dictionary\n    # containing segmentation, area, bbox, predicted_iou, point_coords, stability_score, and crop_box\n    self.masks = None\n    self.objects = None  # Store the mask objects as a numpy array\n    # Store the annotations (objects with random color) as a numpy array.\n    self.annotations = None\n\n    # Store the predicted masks, iou_predictions, and low_res_masks\n    self.prediction = None\n    self.scores = None\n    self.logits = None\n\n    # Build the SAM model\n    self.sam = sam_model_registry[self.model_type](checkpoint=self.checkpoint)\n    self.sam.to(device=self.device)\n    # Use optional arguments for fine-tuning the SAM model\n    sam_kwargs = self.sam_kwargs if self.sam_kwargs is not None else {}\n\n    if automatic:\n        # Segment the entire image using the automatic mask generator\n        self.mask_generator = SamAutomaticMaskGenerator(self.sam, **sam_kwargs)\n    else:\n        # Segment selected objects using input prompts\n        self.predictor = SamPredictor(self.sam, **sam_kwargs)\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.generate","title":"<code>generate(self, source, output=None, foreground=True, batch=False, erosion_kernel=None, mask_multiplier=255, unique=True, **kwargs)</code>","text":"<p>Generate masks for the input image.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str | np.ndarray</code> <p>The path to the input image or the input image as a numpy array.</p> required <code>output</code> <code>str</code> <p>The path to the output image. Defaults to None.</p> <code>None</code> <code>foreground</code> <code>bool</code> <p>Whether to generate the foreground mask. Defaults to True.</p> <code>True</code> <code>batch</code> <code>bool</code> <p>Whether to generate masks for a batch of image tiles. Defaults to False.</p> <code>False</code> <code>erosion_kernel</code> <code>tuple</code> <p>The erosion kernel for filtering object masks and extract borders. Such as (3, 3) or (5, 5). Set to None to disable it. Defaults to None.</p> <code>None</code> <code>mask_multiplier</code> <code>int</code> <p>The mask multiplier for the output mask, which is usually a binary mask [0, 1]. You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255. The parameter is ignored if unique is True.</p> <code>255</code> <code>unique</code> <code>bool</code> <p>Whether to assign a unique value to each object. Defaults to True. The unique value increases from 1 to the number of objects. The larger the number, the larger the object area.</p> <code>True</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def generate(\n    self,\n    source,\n    output=None,\n    foreground=True,\n    batch=False,\n    erosion_kernel=None,\n    mask_multiplier=255,\n    unique=True,\n    **kwargs,\n):\n\"\"\"Generate masks for the input image.\n\n    Args:\n        source (str | np.ndarray): The path to the input image or the input image as a numpy array.\n        output (str, optional): The path to the output image. Defaults to None.\n        foreground (bool, optional): Whether to generate the foreground mask. Defaults to True.\n        batch (bool, optional): Whether to generate masks for a batch of image tiles. Defaults to False.\n        erosion_kernel (tuple, optional): The erosion kernel for filtering object masks and extract borders.\n            Such as (3, 3) or (5, 5). Set to None to disable it. Defaults to None.\n        mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n            You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.\n            The parameter is ignored if unique is True.\n        unique (bool, optional): Whether to assign a unique value to each object. Defaults to True.\n            The unique value increases from 1 to the number of objects. The larger the number, the larger the object area.\n\n    \"\"\"\n\n    if isinstance(source, str):\n        if source.startswith(\"http\"):\n            source = download_file(source)\n\n        if not os.path.exists(source):\n            raise ValueError(f\"Input path {source} does not exist.\")\n\n        if batch:  # Subdivide the image into tiles and segment each tile\n            return tiff_to_tiff(\n                source,\n                output,\n                self,\n                foreground=foreground,\n                erosion_kernel=erosion_kernel,\n                mask_multiplier=mask_multiplier,\n                **kwargs,\n            )\n\n        image = cv2.imread(source)\n    elif isinstance(source, np.ndarray):\n        image = source\n    else:\n        raise ValueError(\"Input source must be either a path or a numpy array.\")\n\n    self.source = source  # Store the input image path\n    self.image = image  # Store the input image as a numpy array\n    mask_generator = self.mask_generator  # The automatic mask generator\n    masks = mask_generator.generate(image)  # Segment the input image\n    self.masks = masks  # Store the masks as a list of dictionaries\n\n    if output is not None:\n        # Save the masks to the output path. The output is either a binary mask or a mask of objects with unique values.\n        self.save_masks(\n            output, foreground, unique, erosion_kernel, mask_multiplier, **kwargs\n        )\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.predict","title":"<code>predict(self, point_coords=None, point_labels=None, box=None, point_crs=None, mask_input=None, multimask_output=True, return_logits=False, output=None, index=None, mask_multiplier=255, dtype=&lt;class 'numpy.float32'&gt;, return_results=False, **kwargs)</code>","text":"<p>Predict masks for the given input prompts, using the currently set image.</p> <p>Parameters:</p> Name Type Description Default <code>point_coords</code> <code>str | dict | list | np.ndarray</code> <p>A Nx2 array of point prompts to the model. Each point is in (X,Y) in pixels. It can be a path to a vector file, a GeoJSON dictionary, a list of coordinates [lon, lat], or a numpy array. Defaults to None.</p> <code>None</code> <code>point_labels</code> <code>list | int | np.ndarray</code> <p>A length N array of labels for the point prompts. 1 indicates a foreground point and 0 indicates a background point.</p> <code>None</code> <code>point_crs</code> <code>str</code> <p>The coordinate reference system (CRS) of the point prompts.</p> <code>None</code> <code>box</code> <code>list | np.ndarray</code> <p>A length 4 array given a box prompt to the model, in XYXY format.</p> <code>None</code> <code>mask_input</code> <code>np.ndarray</code> <p>A low resolution mask input to the model, typically coming from a previous prediction iteration. Has form 1xHxW, where for SAM, H=W=256. multimask_output (bool, optional): If true, the model will return three masks. For ambiguous input prompts (such as a single click), this will often produce better masks than a single prediction. If only a single mask is needed, the model's predicted quality score can be used to select the best mask. For non-ambiguous prompts, such as multiple input prompts, multimask_output=False can give better results.</p> <code>None</code> <code>return_logits</code> <code>bool</code> <p>If true, returns un-thresholded masks logits instead of a binary mask.</p> <code>False</code> <code>output</code> <code>str</code> <p>The path to the output image. Defaults to None.</p> <code>None</code> <code>index</code> <code>index</code> <p>The index of the mask to save. Defaults to None, which will save the mask with the highest score.</p> <code>None</code> <code>mask_multiplier</code> <code>int</code> <p>The mask multiplier for the output mask, which is usually a binary mask [0, 1].</p> <code>255</code> <code>dtype</code> <code>np.dtype</code> <p>The data type of the output image. Defaults to np.float32.</p> <code>&lt;class 'numpy.float32'&gt;</code> <code>return_results</code> <code>bool</code> <p>Whether to return the predicted masks, scores, and logits. Defaults to False.</p> <code>False</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def predict(\n    self,\n    point_coords=None,\n    point_labels=None,\n    box=None,\n    point_crs=None,\n    mask_input=None,\n    multimask_output=True,\n    return_logits=False,\n    output=None,\n    index=None,\n    mask_multiplier=255,\n    dtype=np.float32,\n    return_results=False,\n    **kwargs,\n):\n\"\"\"Predict masks for the given input prompts, using the currently set image.\n\n    Args:\n        point_coords (str | dict | list | np.ndarray, optional): A Nx2 array of point prompts to the\n            model. Each point is in (X,Y) in pixels. It can be a path to a vector file, a GeoJSON\n            dictionary, a list of coordinates [lon, lat], or a numpy array. Defaults to None.\n        point_labels (list | int | np.ndarray, optional): A length N array of labels for the\n            point prompts. 1 indicates a foreground point and 0 indicates a background point.\n        point_crs (str, optional): The coordinate reference system (CRS) of the point prompts.\n        box (list | np.ndarray, optional): A length 4 array given a box prompt to the\n            model, in XYXY format.\n        mask_input (np.ndarray, optional): A low resolution mask input to the model, typically\n            coming from a previous prediction iteration. Has form 1xHxW, where for SAM, H=W=256.\n            multimask_output (bool, optional): If true, the model will return three masks.\n            For ambiguous input prompts (such as a single click), this will often\n            produce better masks than a single prediction. If only a single\n            mask is needed, the model's predicted quality score can be used\n            to select the best mask. For non-ambiguous prompts, such as multiple\n            input prompts, multimask_output=False can give better results.\n        return_logits (bool, optional): If true, returns un-thresholded masks logits\n            instead of a binary mask.\n        output (str, optional): The path to the output image. Defaults to None.\n        index (index, optional): The index of the mask to save. Defaults to None,\n            which will save the mask with the highest score.\n        mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n        dtype (np.dtype, optional): The data type of the output image. Defaults to np.float32.\n        return_results (bool, optional): Whether to return the predicted masks, scores, and logits. Defaults to False.\n\n    \"\"\"\n\n    if isinstance(point_coords, str):\n        point_coords = vector_to_geojson(point_coords)\n\n    if isinstance(point_coords, dict):\n        point_coords = geojson_to_coords(point_coords)\n\n    if point_crs is not None:\n        point_coords = coords_to_xy(self.image, point_coords, point_crs)\n\n    if isinstance(point_coords, list):\n        point_coords = np.array(point_coords)\n\n    if point_labels is None:\n        point_labels = [1] * len(point_coords)\n    elif isinstance(point_labels, int):\n        point_labels = [point_labels] * len(point_coords)\n\n    if isinstance(point_labels, list):\n        if len(point_labels) != len(point_coords):\n            if len(point_labels) == 1:\n                point_labels = point_labels * len(point_coords)\n            else:\n                raise ValueError(\n                    \"The length of point_labels must be equal to the length of point_coords.\"\n                )\n        point_labels = np.array(point_labels)\n\n    if isinstance(box, list) and point_crs is not None:\n        box = np.array(bbox_to_xy(self.image, box, point_crs))\n\n    predictor = self.predictor\n    masks, scores, logits = predictor.predict(\n        point_coords, point_labels, box, mask_input, multimask_output, return_logits\n    )\n    self.masks = masks\n    self.scores = scores\n    self.logits = logits\n\n    if output is not None:\n        self.save_prediction(output, index, mask_multiplier, dtype, **kwargs)\n\n    if return_results:\n        return masks, scores, logits\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.save_masks","title":"<code>save_masks(self, output=None, foreground=True, unique=True, erosion_kernel=None, mask_multiplier=255, **kwargs)</code>","text":"<p>Save the masks to the output path. The output is either a binary mask or a mask of objects with unique values.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The path to the output image. Defaults to None, saving the masks to SamGeo.objects.</p> <code>None</code> <code>foreground</code> <code>bool</code> <p>Whether to generate the foreground mask. Defaults to True.</p> <code>True</code> <code>unique</code> <code>bool</code> <p>Whether to assign a unique value to each object. Defaults to True.</p> <code>True</code> <code>erosion_kernel</code> <code>tuple</code> <p>The erosion kernel for filtering object masks and extract borders. Such as (3, 3) or (5, 5). Set to None to disable it. Defaults to None.</p> <code>None</code> <code>mask_multiplier</code> <code>int</code> <p>The mask multiplier for the output mask, which is usually a binary mask [0, 1]. You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.</p> <code>255</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def save_masks(\n    self,\n    output=None,\n    foreground=True,\n    unique=True,\n    erosion_kernel=None,\n    mask_multiplier=255,\n    **kwargs,\n):\n\"\"\"Save the masks to the output path. The output is either a binary mask or a mask of objects with unique values.\n\n    Args:\n        output (str, optional): The path to the output image. Defaults to None, saving the masks to SamGeo.objects.\n        foreground (bool, optional): Whether to generate the foreground mask. Defaults to True.\n        unique (bool, optional): Whether to assign a unique value to each object. Defaults to True.\n        erosion_kernel (tuple, optional): The erosion kernel for filtering object masks and extract borders.\n            Such as (3, 3) or (5, 5). Set to None to disable it. Defaults to None.\n        mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n            You can use this parameter to scale the mask to a larger range, for example [0, 255]. Defaults to 255.\n\n    \"\"\"\n\n    if self.masks is None:\n        raise ValueError(\"No masks found. Please run generate() first.\")\n\n    h, w, _ = self.image.shape\n    masks = self.masks\n\n    # Set output image data type based on the number of objects\n    if len(masks) &lt; 255:\n        dtype = np.uint8\n    elif len(masks) &lt; 65535:\n        dtype = np.uint16\n    else:\n        dtype = np.uint32\n\n    # Generate a mask of objects with unique values\n    if unique:\n        # Sort the masks by area in ascending order\n        sorted_masks = sorted(masks, key=(lambda x: x[\"area\"]), reverse=False)\n\n        # Create an output image with the same size as the input image\n        objects = np.zeros(\n            (\n                sorted_masks[0][\"segmentation\"].shape[0],\n                sorted_masks[0][\"segmentation\"].shape[1],\n            )\n        )\n        # Assign a unique value to each object\n        for index, ann in enumerate(sorted_masks):\n            m = ann[\"segmentation\"]\n            objects[m] = index + 1\n\n    # Generate a binary mask\n    else:\n        if foreground:  # Extract foreground objects only\n            resulting_mask = np.zeros((h, w), dtype=dtype)\n        else:\n            resulting_mask = np.ones((h, w), dtype=dtype)\n        resulting_borders = np.zeros((h, w), dtype=dtype)\n\n        for m in masks:\n            mask = (m[\"segmentation\"] &gt; 0).astype(dtype)\n            resulting_mask += mask\n\n            # Apply erosion to the mask\n            if erosion_kernel is not None:\n                mask_erode = cv2.erode(mask, erosion_kernel, iterations=1)\n                mask_erode = (mask_erode &gt; 0).astype(dtype)\n                edge_mask = mask - mask_erode\n                resulting_borders += edge_mask\n\n        resulting_mask = (resulting_mask &gt; 0).astype(dtype)\n        resulting_borders = (resulting_borders &gt; 0).astype(dtype)\n        objects = resulting_mask - resulting_borders\n        objects = objects * mask_multiplier\n\n    objects = objects.astype(dtype)\n    self.objects = objects\n\n    if output is not None:  # Save the output image\n        array_to_image(self.objects, output, self.source, **kwargs)\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.save_prediction","title":"<code>save_prediction(self, output, index=None, mask_multiplier=255, dtype=&lt;class 'numpy.float32'&gt;, vector=None, simplify_tolerance=None, **kwargs)</code>","text":"<p>Save the predicted mask to the output path.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The path to the output image.</p> required <code>index</code> <code>int</code> <p>The index of the mask to save. Defaults to None, which will save the mask with the highest score.</p> <code>None</code> <code>mask_multiplier</code> <code>int</code> <p>The mask multiplier for the output mask, which is usually a binary mask [0, 1].</p> <code>255</code> <code>vector</code> <code>str</code> <p>The path to the output vector file. Defaults to None.</p> <code>None</code> <code>dtype</code> <code>np.dtype</code> <p>The data type of the output image. Defaults to np.float32.</p> <code>&lt;class 'numpy.float32'&gt;</code> <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def save_prediction(\n    self,\n    output,\n    index=None,\n    mask_multiplier=255,\n    dtype=np.float32,\n    vector=None,\n    simplify_tolerance=None,\n    **kwargs,\n):\n\"\"\"Save the predicted mask to the output path.\n\n    Args:\n        output (str): The path to the output image.\n        index (int, optional): The index of the mask to save. Defaults to None,\n            which will save the mask with the highest score.\n        mask_multiplier (int, optional): The mask multiplier for the output mask, which is usually a binary mask [0, 1].\n        vector (str, optional): The path to the output vector file. Defaults to None.\n        dtype (np.dtype, optional): The data type of the output image. Defaults to np.float32.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n\n    \"\"\"\n    if self.scores is None:\n        raise ValueError(\"No predictions found. Please run predict() first.\")\n\n    if index is None:\n        index = self.scores.argmax(axis=0)\n\n    array = self.masks[index] * mask_multiplier\n    self.prediction = array\n    array_to_image(array, output, self.image, dtype=dtype, **kwargs)\n\n    if vector is not None:\n        raster_to_vector(output, vector, simplify_tolerance=simplify_tolerance)\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.set_image","title":"<code>set_image(self, image, image_format='RGB')</code>","text":"<p>Set the input image as a numpy array.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>The input image as a numpy array.</p> required <code>image_format</code> <code>str</code> <p>The image format, can be RGB or BGR. Defaults to \"RGB\".</p> <code>'RGB'</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def set_image(self, image, image_format=\"RGB\"):\n\"\"\"Set the input image as a numpy array.\n\n    Args:\n        image (np.ndarray): The input image as a numpy array.\n        image_format (str, optional): The image format, can be RGB or BGR. Defaults to \"RGB\".\n    \"\"\"\n    if isinstance(image, str):\n        if image.startswith(\"http\"):\n            image = download_file(image)\n\n        if not os.path.exists(image):\n            raise ValueError(f\"Input path {image} does not exist.\")\n\n        self.image = image\n\n        image = cv2.imread(image)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    elif isinstance(image, np.ndarray):\n        pass\n    else:\n        raise ValueError(\"Input image must be either a path or a numpy array.\")\n\n    self.predictor.set_image(image, image_format=image_format)\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.show_anns","title":"<code>show_anns(self, figsize=(12, 10), axis='off', alpha=0.35, output=None, **kwargs)</code>","text":"<p>Show the annotations (objects with random color) on the input image.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple</code> <p>The figure size. Defaults to (12, 10).</p> <code>(12, 10)</code> <code>axis</code> <code>str</code> <p>Whether to show the axis. Defaults to \"off\".</p> <code>'off'</code> <code>alpha</code> <code>float</code> <p>The alpha value for the annotations. Defaults to 0.35.</p> <code>0.35</code> <code>output</code> <code>str</code> <p>The path to the output image. Defaults to None.</p> <code>None</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def show_anns(\n    self, figsize=(12, 10), axis=\"off\", alpha=0.35, output=None, **kwargs\n):\n\"\"\"Show the annotations (objects with random color) on the input image.\n\n    Args:\n        figsize (tuple, optional): The figure size. Defaults to (12, 10).\n        axis (str, optional): Whether to show the axis. Defaults to \"off\".\n        alpha (float, optional): The alpha value for the annotations. Defaults to 0.35.\n        output (str, optional): The path to the output image. Defaults to None.\n    \"\"\"\n\n    import matplotlib.pyplot as plt\n\n    anns = self.masks\n\n    if self.image is None:\n        print(\"Please run generate() first.\")\n        return\n\n    if anns is None or len(anns) == 0:\n        return\n\n    plt.figure(figsize=figsize)\n    plt.imshow(self.image)\n\n    sorted_anns = sorted(anns, key=(lambda x: x[\"area\"]), reverse=True)\n\n    ax = plt.gca()\n    ax.set_autoscale_on(False)\n\n    img = np.ones(\n        (\n            sorted_anns[0][\"segmentation\"].shape[0],\n            sorted_anns[0][\"segmentation\"].shape[1],\n            4,\n        )\n    )\n    img[:, :, 3] = 0\n    for ann in sorted_anns:\n        m = ann[\"segmentation\"]\n        color_mask = np.concatenate([np.random.random(3), [alpha]])\n        img[m] = color_mask\n    ax.imshow(img)\n\n    if \"dpi\" not in kwargs:\n        kwargs[\"dpi\"] = 100\n\n    if \"bbox_inches\" not in kwargs:\n        kwargs[\"bbox_inches\"] = \"tight\"\n\n    plt.axis(axis)\n\n    self.annotations = (img[:, :, 0:3] * 255).astype(np.uint8)\n\n    if output is not None:\n        array = blend_images(self.annotations, self.image, alpha=alpha, show=False)\n        array_to_image(array, output, self.source)\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.show_masks","title":"<code>show_masks(self, figsize=(12, 10), cmap='binary_r', axis='off', foreground=True, **kwargs)</code>","text":"<p>Show the binary mask or the mask of objects with unique values.</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple</code> <p>The figure size. Defaults to (12, 10).</p> <code>(12, 10)</code> <code>cmap</code> <code>str</code> <p>The colormap. Defaults to \"binary_r\".</p> <code>'binary_r'</code> <code>axis</code> <code>str</code> <p>Whether to show the axis. Defaults to \"off\".</p> <code>'off'</code> <code>foreground</code> <code>bool</code> <p>Whether to show the foreground mask only. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Other arguments for save_masks().</p> <code>{}</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def show_masks(\n    self, figsize=(12, 10), cmap=\"binary_r\", axis=\"off\", foreground=True, **kwargs\n):\n\"\"\"Show the binary mask or the mask of objects with unique values.\n\n    Args:\n        figsize (tuple, optional): The figure size. Defaults to (12, 10).\n        cmap (str, optional): The colormap. Defaults to \"binary_r\".\n        axis (str, optional): Whether to show the axis. Defaults to \"off\".\n        foreground (bool, optional): Whether to show the foreground mask only. Defaults to True.\n        **kwargs: Other arguments for save_masks().\n    \"\"\"\n\n    import matplotlib.pyplot as plt\n\n    if self.objects is None:\n        self.save_masks(foreground=foreground, **kwargs)\n\n    plt.figure(figsize=figsize)\n    plt.imshow(self.objects, cmap=cmap)\n    plt.axis(axis)\n    plt.show()\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.tiff_to_geojson","title":"<code>tiff_to_geojson(self, tiff_path, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Convert a tiff file to a GeoJSON file.</p> <p>Parameters:</p> Name Type Description Default <code>tiff_path</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the GeoJSON file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def tiff_to_geojson(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a GeoJSON file.\n\n    Args:\n        tiff_path (str): The path to the tiff file.\n        output (str): The path to the GeoJSON file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n\n    raster_to_geojson(\n        tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n    )\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.tiff_to_gpkg","title":"<code>tiff_to_gpkg(self, tiff_path, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Convert a tiff file to a gpkg file.</p> <p>Parameters:</p> Name Type Description Default <code>tiff_path</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the gpkg file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def tiff_to_gpkg(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a gpkg file.\n\n    Args:\n        tiff_path (str): The path to the tiff file.\n        output (str): The path to the gpkg file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n\n    raster_to_gpkg(\n        tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n    )\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.tiff_to_shp","title":"<code>tiff_to_shp(self, tiff_path, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Convert a tiff file to a shapefile.</p> <p>Parameters:</p> Name Type Description Default <code>tiff_path</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the shapefile.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def tiff_to_shp(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a shapefile.\n\n    Args:\n        tiff_path (str): The path to the tiff file.\n        output (str): The path to the shapefile.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n\n    raster_to_shp(\n        tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n    )\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeo.tiff_to_vector","title":"<code>tiff_to_vector(self, tiff_path, output, simplify_tolerance=None, **kwargs)</code>","text":"<p>Convert a tiff file to a gpkg file.</p> <p>Parameters:</p> Name Type Description Default <code>tiff_path</code> <code>str</code> <p>The path to the tiff file.</p> required <code>output</code> <code>str</code> <p>The path to the vector file.</p> required <code>simplify_tolerance</code> <code>float</code> <p>The maximum allowed geometry displacement. The higher this value, the smaller the number of vertices in the resulting geometry.</p> <code>None</code> Source code in <code>samgeo/samgeo.py</code> <pre><code>def tiff_to_vector(self, tiff_path, output, simplify_tolerance=None, **kwargs):\n\"\"\"Convert a tiff file to a gpkg file.\n\n    Args:\n        tiff_path (str): The path to the tiff file.\n        output (str): The path to the vector file.\n        simplify_tolerance (float, optional): The maximum allowed geometry displacement.\n            The higher this value, the smaller the number of vertices in the resulting geometry.\n    \"\"\"\n\n    raster_to_vector(\n        tiff_path, output, simplify_tolerance=simplify_tolerance, **kwargs\n    )\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeoPredictor","title":"<code> SamGeoPredictor            (SamPredictor)         </code>","text":"Source code in <code>samgeo/samgeo.py</code> <pre><code>class SamGeoPredictor(SamPredictor):\n    def __init__(\n        self,\n        sam_model,\n    ):\n        from segment_anything.utils.transforms import ResizeLongestSide\n\n        self.model = sam_model\n        self.transform = ResizeLongestSide(sam_model.image_encoder.img_size)\n\n    def set_image(self, image):\n        super(SamGeoPredictor, self).set_image(image)\n\n    def predict(\n        self,\n        src_fp=None,\n        geo_box=None,\n        point_coords=None,\n        point_labels=None,\n        box=None,\n        mask_input=None,\n        multimask_output=True,\n        return_logits=False,\n    ):\n        if geo_box and src_fp:\n            self.crs = \"EPSG:4326\"\n            dst_crs = get_crs(src_fp)\n            sw = transform_coords(geo_box[0], geo_box[1], self.crs, dst_crs)\n            ne = transform_coords(geo_box[2], geo_box[3], self.crs, dst_crs)\n            xs = np.array([sw[0], ne[0]])\n            ys = np.array([sw[1], ne[1]])\n            box = get_pixel_coords(src_fp, xs, ys)\n            self.geo_box = geo_box\n            self.width = box[2] - box[0]\n            self.height = box[3] - box[1]\n            self.geo_transform = set_transform(geo_box, self.width, self.height)\n\n        masks, iou_predictions, low_res_masks = super(SamGeoPredictor, self).predict(\n            point_coords, point_labels, box, mask_input, multimask_output, return_logits\n        )\n\n        return masks, iou_predictions, low_res_masks\n\n    def masks_to_geotiff(self, src_fp, dst_fp, masks):\n        profile = get_profile(src_fp)\n        write_raster(\n            dst_fp,\n            masks,\n            profile,\n            self.width,\n            self.height,\n            self.geo_transform,\n            self.crs,\n        )\n\n    def geotiff_to_geojson(self, src_fp, dst_fp, bidx=1):\n        gdf = get_features(src_fp, bidx)\n        write_features(gdf, dst_fp)\n        return gdf\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeoPredictor.predict","title":"<code>predict(self, src_fp=None, geo_box=None, point_coords=None, point_labels=None, box=None, mask_input=None, multimask_output=True, return_logits=False)</code>","text":"<p>Predict masks for the given input prompts, using the currently set image.</p> <p>Parameters:</p> Name Type Description Default <code>point_coords</code> <code>np.ndarray or None</code> <p>A Nx2 array of point prompts to the model. Each point is in (X,Y) in pixels.</p> <code>None</code> <code>point_labels</code> <code>np.ndarray or None</code> <p>A length N array of labels for the point prompts. 1 indicates a foreground point and 0 indicates a background point.</p> <code>None</code> <code>box</code> <code>np.ndarray or None</code> <p>A length 4 array given a box prompt to the model, in XYXY format.</p> <code>None</code> <code>mask_input</code> <code>np.ndarray</code> <p>A low resolution mask input to the model, typically coming from a previous prediction iteration. Has form 1xHxW, where for SAM, H=W=256.</p> <code>None</code> <code>multimask_output</code> <code>bool</code> <p>If true, the model will return three masks. For ambiguous input prompts (such as a single click), this will often produce better masks than a single prediction. If only a single mask is needed, the model's predicted quality score can be used to select the best mask. For non-ambiguous prompts, such as multiple input prompts, multimask_output=False can give better results.</p> <code>True</code> <code>return_logits</code> <code>bool</code> <p>If true, returns un-thresholded masks logits instead of a binary mask.</p> <code>False</code> <p>Returns:</p> Type Description <code>(np.ndarray)</code> <p>The output masks in CxHxW format, where C is the   number of masks, and (H, W) is the original image size. (np.ndarray): An array of length C containing the model's   predictions for the quality of each mask. (np.ndarray): An array of shape CxHxW, where C is the number   of masks and H=W=256. These low resolution logits can be passed to   a subsequent iteration as mask input.</p> Source code in <code>samgeo/samgeo.py</code> <pre><code>def predict(\n    self,\n    src_fp=None,\n    geo_box=None,\n    point_coords=None,\n    point_labels=None,\n    box=None,\n    mask_input=None,\n    multimask_output=True,\n    return_logits=False,\n):\n    if geo_box and src_fp:\n        self.crs = \"EPSG:4326\"\n        dst_crs = get_crs(src_fp)\n        sw = transform_coords(geo_box[0], geo_box[1], self.crs, dst_crs)\n        ne = transform_coords(geo_box[2], geo_box[3], self.crs, dst_crs)\n        xs = np.array([sw[0], ne[0]])\n        ys = np.array([sw[1], ne[1]])\n        box = get_pixel_coords(src_fp, xs, ys)\n        self.geo_box = geo_box\n        self.width = box[2] - box[0]\n        self.height = box[3] - box[1]\n        self.geo_transform = set_transform(geo_box, self.width, self.height)\n\n    masks, iou_predictions, low_res_masks = super(SamGeoPredictor, self).predict(\n        point_coords, point_labels, box, mask_input, multimask_output, return_logits\n    )\n\n    return masks, iou_predictions, low_res_masks\n</code></pre>"},{"location":"samgeo/#samgeo.samgeo.SamGeoPredictor.set_image","title":"<code>set_image(self, image)</code>","text":"<p>Calculates the image embeddings for the provided image, allowing masks to be predicted with the 'predict' method.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>np.ndarray</code> <p>The image for calculating masks. Expects an image in HWC uint8 format, with pixel values in [0, 255].</p> required <code>image_format</code> <code>str</code> <p>The color format of the image, in ['RGB', 'BGR'].</p> required Source code in <code>samgeo/samgeo.py</code> <pre><code>def set_image(self, image):\n    super(SamGeoPredictor, self).set_image(image)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use segment-geospatial in a project:</p> <pre><code>import samgeo\n</code></pre> <p>Here is a simple example of using segment-geospatial to generate a segmentation mask from a satellite image:</p> <pre><code>import os\nimport torch\nfrom samgeo import SamGeo, tms_to_geotiff\n\nbbox = [-95.3704, 29.6762, -95.368, 29.6775]\nimage = 'satellite.tif'\ntms_to_geotiff(output=image, bbox=bbox, zoom=20, source='Satellite')\n\nout_dir = os.path.join(os.path.expanduser('~'), 'Downloads')\ncheckpoint = os.path.join(out_dir, 'sam_vit_h_4b8939.pth')\n\ndevice = 'cuda' if torch.cuda.is_available() else 'cpu'\nsam = SamGeo(\n    checkpoint=checkpoint,\n    model_type='vit_h',\n    device=device,\n    erosion_kernel=(3, 3),\n    mask_multiplier=255,\n    sam_kwargs=None,\n)\n\nmask = 'segment.tiff'\nsam.generate(image, mask)\n\nvector = 'segment.gpkg'\nsam.tiff_to_gpkg(mask, vector, simplify_tolerance=None)\n</code></pre> <p></p>"},{"location":"examples/automatic_mask_generator/","title":"Automatic mask generator","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install segment-geospatial leafmap localtileserver\n</pre> # %pip install segment-geospatial leafmap localtileserver In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nfrom samgeo import SamGeo, show_image, download_file, overlay_images, tms_to_geotiff\n</pre> import os import leafmap from samgeo import SamGeo, show_image, download_file, overlay_images, tms_to_geotiff In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[37.8713, -122.2580], zoom=17, height=\"800px\")\nm.add_basemap(\"SATELLITE\")\nm\n</pre> m = leafmap.Map(center=[37.8713, -122.2580], zoom=17, height=\"800px\") m.add_basemap(\"SATELLITE\") m <p>Pan and zoom the map to select the area of interest. Use the draw tools to draw a polygon or rectangle on the map</p> In\u00a0[\u00a0]: Copied! <pre>if m.user_roi_bounds() is not None:\n    bbox = m.user_roi_bounds()\nelse:\n    bbox = [-122.2659, 37.8682, -122.2521, 37.8741]\n</pre> if m.user_roi_bounds() is not None:     bbox = m.user_roi_bounds() else:     bbox = [-122.2659, 37.8682, -122.2521, 37.8741] In\u00a0[\u00a0]: Copied! <pre>image = \"satellite.tif\"\ntms_to_geotiff(output=image, bbox=bbox, zoom=17, source=\"Satellite\", overwrite=True)\n</pre> image = \"satellite.tif\" tms_to_geotiff(output=image, bbox=bbox, zoom=17, source=\"Satellite\", overwrite=True) <p>You can also use your own image. Uncomment and run the following cell to use your own image.</p> In\u00a0[\u00a0]: Copied! <pre># image = '/path/to/your/own/image.tif'\n</pre> # image = '/path/to/your/own/image.tif' <p>Display the downloaded image on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.layers[-1].visible = False\nm.add_raster(image, layer_name=\"Image\")\nm\n</pre> m.layers[-1].visible = False m.add_raster(image, layer_name=\"Image\") m In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\ncheckpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\")\n</pre> out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\") checkpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\") In\u00a0[\u00a0]: Copied! <pre>sam = SamGeo(\n    model_type=\"vit_h\",\n    checkpoint=checkpoint,\n    sam_kwargs=None,\n)\n</pre> sam = SamGeo(     model_type=\"vit_h\",     checkpoint=checkpoint,     sam_kwargs=None, ) In\u00a0[\u00a0]: Copied! <pre>sam.generate(image, output=\"masks.tif\", foreground=True, unique=True)\n</pre> sam.generate(image, output=\"masks.tif\", foreground=True, unique=True) In\u00a0[\u00a0]: Copied! <pre>sam.show_masks(cmap=\"binary_r\")\n</pre> sam.show_masks(cmap=\"binary_r\") <p>Show the object annotations (objects with random color) on the map.</p> In\u00a0[\u00a0]: Copied! <pre>sam.show_anns(axis=\"off\", alpha=1, output=\"annotations.tif\")\n</pre> sam.show_anns(axis=\"off\", alpha=1, output=\"annotations.tif\") <p>Compare images with a slider.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.image_comparison(\n    \"satellite.tif\",\n    \"annotations.tif\",\n    label1=\"Satellite Image\",\n    label2=\"Image Segmentation\",\n)\n</pre> leafmap.image_comparison(     \"satellite.tif\",     \"annotations.tif\",     label1=\"Satellite Image\",     label2=\"Image Segmentation\", ) <p>Add image to the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.add_raster(\"annotations.tif\", alpha=0.5, layer_name=\"Masks\")\nm\n</pre> m.add_raster(\"annotations.tif\", alpha=0.5, layer_name=\"Masks\") m <p>Convert the object annotations to vector format, such as GeoPackage, Shapefile, or GeoJSON.</p> In\u00a0[\u00a0]: Copied! <pre>sam.tiff_to_vector(\"masks.tif\", \"masks.gpkg\")\n</pre> sam.tiff_to_vector(\"masks.tif\", \"masks.gpkg\") In\u00a0[\u00a0]: Copied! <pre>sam_kwargs = {\n    \"points_per_side\": 32,\n    \"pred_iou_thresh\": 0.86,\n    \"stability_score_thresh\": 0.92,\n    \"crop_n_layers\": 1,\n    \"crop_n_points_downscale_factor\": 2,\n    \"min_mask_region_area\": 100,\n}\n</pre> sam_kwargs = {     \"points_per_side\": 32,     \"pred_iou_thresh\": 0.86,     \"stability_score_thresh\": 0.92,     \"crop_n_layers\": 1,     \"crop_n_points_downscale_factor\": 2,     \"min_mask_region_area\": 100, } In\u00a0[\u00a0]: Copied! <pre>sam = SamGeo(\n    model_type=\"vit_h\",\n    checkpoint=checkpoint,\n    sam_kwargs=sam_kwargs,\n)\n</pre> sam = SamGeo(     model_type=\"vit_h\",     checkpoint=checkpoint,     sam_kwargs=sam_kwargs, ) In\u00a0[\u00a0]: Copied! <pre>sam.generate(image, output=\"masks2.tif\", foreground=True)\n</pre> sam.generate(image, output=\"masks2.tif\", foreground=True) In\u00a0[\u00a0]: Copied! <pre>sam.show_masks(cmap=\"binary_r\")\n</pre> sam.show_masks(cmap=\"binary_r\") In\u00a0[\u00a0]: Copied! <pre>sam.show_anns(axis=\"off\", opacity=1, output=\"annotations2.tif\")\n</pre> sam.show_anns(axis=\"off\", opacity=1, output=\"annotations2.tif\") <p>Compare images with a slider.</p> In\u00a0[\u00a0]: Copied! <pre>leafmap.image_comparison(\n    \"satellite.tif\",\n    \"annotations.tif\",\n    label1=\"Satellite Image\",\n    label2=\"Image Segmentation\",\n)\n</pre> leafmap.image_comparison(     \"satellite.tif\",     \"annotations.tif\",     label1=\"Satellite Image\",     label2=\"Image Segmentation\", ) <p>Overlay the annotations on the image and use the slider to change the opacity interactively.</p> In\u00a0[\u00a0]: Copied! <pre>overlay_images(image, \"annotations2.tif\", backend=\"TkAgg\")\n</pre> overlay_images(image, \"annotations2.tif\", backend=\"TkAgg\") <p></p>"},{"location":"examples/automatic_mask_generator/#automatically-generating-object-masks-with-sam","title":"Automatically generating object masks with SAM\u00b6","text":"<p>This notebook shows how to segment objects from an image using the Segment Anything Model (SAM) with a few lines of code.</p> <p>Make sure you use GPU runtime for this notebook. For Google Colab, go to <code>Runtime</code> -&gt; <code>Change runtime type</code> and select <code>GPU</code> as the hardware accelerator.</p> <p>The notebook is adapted from segment-anything/notebooks/automatic_mask_generator_example.ipynb, but I have made it much easier to save the segmentation results and visualize them.</p>"},{"location":"examples/automatic_mask_generator/#install-dependencies","title":"Install dependencies\u00b6","text":"<p>Uncomment and run the following cell to install the required dependencies.</p>"},{"location":"examples/automatic_mask_generator/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"examples/automatic_mask_generator/#download-a-sample-image","title":"Download a sample image\u00b6","text":""},{"location":"examples/automatic_mask_generator/#initialize-sam-class","title":"Initialize SAM class\u00b6","text":"<p>Specify the file path to the model checkpoint. If it is not specified, the model will to downloaded to the working directory.</p>"},{"location":"examples/automatic_mask_generator/#automatic-mask-generation","title":"Automatic mask generation\u00b6","text":"<p>Segment the image and save the results to a GeoTIFF file. Set <code>unique=True</code> to assign a unique ID to each object.</p>"},{"location":"examples/automatic_mask_generator/#automatic-mask-generation-options","title":"Automatic mask generation options\u00b6","text":"<p>There are several tunable parameters in automatic mask generation that control how densely points are sampled and what the thresholds are for removing low quality or duplicate masks. Additionally, generation can be automatically run on crops of the image to get improved performance on smaller objects, and post-processing can remove stray pixels and holes. Here is an example configuration that samples more masks:</p>"},{"location":"examples/input_prompts/","title":"Input prompts","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install segment-geospatial leafmap localtileserver\n</pre> # %pip install segment-geospatial leafmap localtileserver <p>If you encounter any issues, please try to uncomment the following cell and run it to update the package from GitHub. New features are usually added to GitHub first before they are released to PyPI.</p> In\u00a0[\u00a0]: Copied! <pre># %pip install git+https://github.com/opengeos/segment-geospatial.git\n</pre> # %pip install git+https://github.com/opengeos/segment-geospatial.git In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nfrom samgeo import SamGeo, tms_to_geotiff\n</pre> import os import leafmap from samgeo import SamGeo, tms_to_geotiff In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[37.6412, -122.1353], zoom=15, height=\"800px\")\nm.add_basemap(\"SATELLITE\")\nm\n</pre> m = leafmap.Map(center=[37.6412, -122.1353], zoom=15, height=\"800px\") m.add_basemap(\"SATELLITE\") m In\u00a0[\u00a0]: Copied! <pre>if m.user_roi is not None:\n    bbox = m.user_roi_bounds()\nelse:\n    bbox = [-122.1497, 37.6311, -122.1203, 37.6458]\n</pre> if m.user_roi is not None:     bbox = m.user_roi_bounds() else:     bbox = [-122.1497, 37.6311, -122.1203, 37.6458] In\u00a0[\u00a0]: Copied! <pre>image = \"satellite.tif\"\ntms_to_geotiff(output=image, bbox=bbox, zoom=16, source=\"Satellite\", overwrite=True)\n</pre> image = \"satellite.tif\" tms_to_geotiff(output=image, bbox=bbox, zoom=16, source=\"Satellite\", overwrite=True) <p>You can also use your own image. Uncomment and run the following cell to use your own image.</p> In\u00a0[\u00a0]: Copied! <pre># image = '/path/to/your/own/image.tif'\n</pre> # image = '/path/to/your/own/image.tif' <p>Display the downloaded image on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.layers[-1].visible = False\nm.add_raster(image, layer_name=\"Image\")\nm\n</pre> m.layers[-1].visible = False m.add_raster(image, layer_name=\"Image\") m In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\ncheckpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\")\n</pre> out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\") checkpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\") <p>Set <code>automatic=False</code> to disable the <code>SamAutomaticMaskGenerator</code> and enable the <code>SamPredictor</code>.</p> In\u00a0[\u00a0]: Copied! <pre>sam = SamGeo(\n    model_type=\"vit_h\",\n    checkpoint=checkpoint,\n    automatic=False,\n    sam_kwargs=None,\n)\n</pre> sam = SamGeo(     model_type=\"vit_h\",     checkpoint=checkpoint,     automatic=False,     sam_kwargs=None, ) <p>Specify the image to segment.</p> In\u00a0[\u00a0]: Copied! <pre>sam.set_image(image)\n</pre> sam.set_image(image) In\u00a0[\u00a0]: Copied! <pre>point_coords = [[-122.1419, 37.6383]]\nsam.predict(point_coords, point_labels=1, point_crs=\"EPSG:4326\", output='mask1.tif')\nm.add_raster('mask1.tif', layer_name=\"Mask1\", nodata=0, cmap=\"Blues\", opacity=1)\nm\n</pre> point_coords = [[-122.1419, 37.6383]] sam.predict(point_coords, point_labels=1, point_crs=\"EPSG:4326\", output='mask1.tif') m.add_raster('mask1.tif', layer_name=\"Mask1\", nodata=0, cmap=\"Blues\", opacity=1) m <p>Try multiple points input:</p> In\u00a0[\u00a0]: Copied! <pre>point_coords = [[-122.1464, 37.6431], [-122.1449, 37.6415], [-122.1451, 37.6395]]\nsam.predict(point_coords, point_labels=1, point_crs=\"EPSG:4326\", output='mask2.tif')\nm.add_raster('mask2.tif', layer_name=\"Mask2\", nodata=0, cmap=\"Greens\", opacity=1)\nm\n</pre> point_coords = [[-122.1464, 37.6431], [-122.1449, 37.6415], [-122.1451, 37.6395]] sam.predict(point_coords, point_labels=1, point_crs=\"EPSG:4326\", output='mask2.tif') m.add_raster('mask2.tif', layer_name=\"Mask2\", nodata=0, cmap=\"Greens\", opacity=1) m In\u00a0[\u00a0]: Copied! <pre>m = sam.show_map()\nm\n</pre> m = sam.show_map() m <p></p>"},{"location":"examples/input_prompts/#generating-object-masks-from-input-prompts-with-sam","title":"Generating object masks from input prompts with SAM\u00b6","text":"<p>This notebook shows how to generate object masks from input prompts with the Segment Anything Model (SAM).</p> <p>Make sure you use GPU runtime for this notebook. For Google Colab, go to <code>Runtime</code> -&gt; <code>Change runtime type</code> and select <code>GPU</code> as the hardware accelerator.</p> <p>The notebook is adapted from segment-anything/notebooks/predictor_example.ipynb, but I have made it much easier to save the segmentation results and visualize them.</p>"},{"location":"examples/input_prompts/#install-dependencies","title":"Install dependencies\u00b6","text":"<p>Uncomment and run the following cell to install the required dependencies.</p>"},{"location":"examples/input_prompts/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"examples/input_prompts/#download-a-sample-image","title":"Download a sample image\u00b6","text":"<p>Pan and zoom the map to select the area of interest. Use the draw tools to draw a polygon or rectangle on the map</p>"},{"location":"examples/input_prompts/#initialize-sam-class","title":"Initialize SAM class\u00b6","text":"<p>Specify the file path to the model checkpoint. If it is not specified, the model will to downloaded to the working directory.</p>"},{"location":"examples/input_prompts/#image-segmentation-with-input-points","title":"Image segmentation with input points\u00b6","text":"<p>A single point can be used to segment an object. The point can be specified as a tuple of (x, y), such as (col, row) or (lon, lat). The points can also be specified as a file path to a vector dataset. For non (col, row) input points, specify the <code>point_crs</code> parameter, which will automatically transform the points to the image column and row coordinates.</p> <p>Try a single point input:</p>"},{"location":"examples/input_prompts/#interactive-segmentation","title":"Interactive segmentation\u00b6","text":"<p>Display the interactive map and use the marker tool to draw points on the map. Then click on the <code>Segment</code> button to segment the objects. The results will be added to the map automatically. Click on the <code>Reset</code> button to clear the points and the results.</p>"},{"location":"examples/satellite-predictor/","title":"Satellite predictor","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install segment-geospatial leafmap localtileserver\n</pre> # %pip install segment-geospatial leafmap localtileserver In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nfrom samgeo import SamGeoPredictor, tms_to_geotiff, get_basemaps\nfrom segment_anything import sam_model_registry\n</pre> import os import leafmap from samgeo import SamGeoPredictor, tms_to_geotiff, get_basemaps from segment_anything import sam_model_registry In\u00a0[\u00a0]: Copied! <pre>zoom = 16\nm = leafmap.Map(center=[45, -123], zoom=zoom)\nm.add_basemap(\"SATELLITE\")\nm\n</pre> zoom = 16 m = leafmap.Map(center=[45, -123], zoom=zoom) m.add_basemap(\"SATELLITE\") m <p>Pan and zoom the map to select the area of interest. Use the draw tools to draw a polygon or rectangle on the map</p> In\u00a0[\u00a0]: Copied! <pre>if m.user_roi_bounds() is not None:\n    bbox = m.user_roi_bounds()\nelse:\n    bbox = [-123.0127, 44.9957, -122.9874, 45.0045]\n</pre> if m.user_roi_bounds() is not None:     bbox = m.user_roi_bounds() else:     bbox = [-123.0127, 44.9957, -122.9874, 45.0045] In\u00a0[\u00a0]: Copied! <pre>image = \"satellite.tif\"\n# image = '/path/to/your/own/image.tif'\n</pre> image = \"satellite.tif\" # image = '/path/to/your/own/image.tif' <p>Besides the <code>satellite</code> basemap, you can use any of the following basemaps returned by the <code>get_basemaps()</code> function:</p> In\u00a0[\u00a0]: Copied! <pre># get_basemaps().keys()\n</pre> # get_basemaps().keys() <p>Specify the basemap as the source.</p> In\u00a0[\u00a0]: Copied! <pre>tms_to_geotiff(\n    output=image, bbox=bbox, zoom=zoom + 1, source=\"Satellite\", overwrite=True\n)\n</pre> tms_to_geotiff(     output=image, bbox=bbox, zoom=zoom + 1, source=\"Satellite\", overwrite=True ) In\u00a0[\u00a0]: Copied! <pre>m.add_raster(image, layer_name=\"Image\")\nm\n</pre> m.add_raster(image, layer_name=\"Image\") m <p>Use the draw tools to draw a rectangle from which to subset segmentations on the map</p> In\u00a0[\u00a0]: Copied! <pre>if m.user_roi_bounds() is not None:\n    clip_box = m.user_roi_bounds()\nelse:\n    clip_box = [-123.0064, 44.9988, -123.0005, 45.0025]\n</pre> if m.user_roi_bounds() is not None:     clip_box = m.user_roi_bounds() else:     clip_box = [-123.0064, 44.9988, -123.0005, 45.0025] In\u00a0[\u00a0]: Copied! <pre>clip_box\n</pre> clip_box In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\ncheckpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\")\n</pre> out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\") checkpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\") In\u00a0[\u00a0]: Copied! <pre>import cv2\n\nimg_arr = cv2.imread(image)\n\nmodel_type = \"vit_h\"\n\nsam = sam_model_registry[model_type](checkpoint=checkpoint)\n\npredictor = SamGeoPredictor(sam)\n\npredictor.set_image(img_arr)\n\nmasks, _, _ = predictor.predict(src_fp=image, geo_box=clip_box)\n</pre> import cv2  img_arr = cv2.imread(image)  model_type = \"vit_h\"  sam = sam_model_registry[model_type](checkpoint=checkpoint)  predictor = SamGeoPredictor(sam)  predictor.set_image(img_arr)  masks, _, _ = predictor.predict(src_fp=image, geo_box=clip_box) In\u00a0[\u00a0]: Copied! <pre>masks_img = \"preds.tif\"\npredictor.masks_to_geotiff(image, masks_img, masks.astype(\"uint8\"))\n</pre> masks_img = \"preds.tif\" predictor.masks_to_geotiff(image, masks_img, masks.astype(\"uint8\")) In\u00a0[\u00a0]: Copied! <pre>vector = \"feats.geojson\"\ngdf = predictor.geotiff_to_geojson(masks_img, vector, bidx=1)\ngdf.plot()\n</pre> vector = \"feats.geojson\" gdf = predictor.geotiff_to_geojson(masks_img, vector, bidx=1) gdf.plot() In\u00a0[\u00a0]: Copied! <pre>style = {\n    \"color\": \"#3388ff\",\n    \"weight\": 2,\n    \"fillColor\": \"#7c4185\",\n    \"fillOpacity\": 0.5,\n}\nm.add_vector(vector, layer_name=\"Vector\", style=style)\nm\n</pre> style = {     \"color\": \"#3388ff\",     \"weight\": 2,     \"fillColor\": \"#7c4185\",     \"fillOpacity\": 0.5, } m.add_vector(vector, layer_name=\"Vector\", style=style) m"},{"location":"examples/satellite-predictor/#segment-anything-model-for-geospatial-data","title":"Segment Anything Model for Geospatial Data\u00b6","text":"<p>This notebook shows how to use segment satellite imagery using the Segment Anything Model (SAM) with a few lines of code.</p> <p>Make sure you use GPU runtime for this notebook. For Google Colab, go to <code>Runtime</code> -&gt; <code>Change runtime type</code> and select <code>GPU</code> as the hardware accelerator.</p>"},{"location":"examples/satellite-predictor/#install-dependencies","title":"Install dependencies\u00b6","text":"<p>Uncomment and run the following cell to install the required dependencies.</p>"},{"location":"examples/satellite-predictor/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/satellite-predictor/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"examples/satellite-predictor/#download-map-tiles","title":"Download map tiles\u00b6","text":"<p>Download maps tiles and mosaic them into a single GeoTIFF file</p>"},{"location":"examples/satellite-predictor/#initialize-samgeopredictor-class","title":"Initialize SamGeoPredictor class\u00b6","text":""},{"location":"examples/satellite-predictor/#visualize-the-results","title":"Visualize the results\u00b6","text":""},{"location":"examples/satellite/","title":"Satellite","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install segment-geospatial leafmap localtileserver\n</pre> # %pip install segment-geospatial leafmap localtileserver In\u00a0[\u00a0]: Copied! <pre>import os\nimport leafmap\nfrom samgeo import SamGeo, tms_to_geotiff, get_basemaps\n</pre> import os import leafmap from samgeo import SamGeo, tms_to_geotiff, get_basemaps In\u00a0[\u00a0]: Copied! <pre>m = leafmap.Map(center=[29.676840, -95.369222], zoom=19)\nm.add_basemap(\"SATELLITE\")\nm\n</pre> m = leafmap.Map(center=[29.676840, -95.369222], zoom=19) m.add_basemap(\"SATELLITE\") m <p>Pan and zoom the map to select the area of interest. Use the draw tools to draw a polygon or rectangle on the map</p> In\u00a0[\u00a0]: Copied! <pre>if m.user_roi_bounds() is not None:\n    bbox = m.user_roi_bounds()\nelse:\n    bbox = [-95.3704, 29.6762, -95.368, 29.6775]\n</pre> if m.user_roi_bounds() is not None:     bbox = m.user_roi_bounds() else:     bbox = [-95.3704, 29.6762, -95.368, 29.6775] In\u00a0[\u00a0]: Copied! <pre>image = \"satellite.tif\"\n</pre> image = \"satellite.tif\" <p>Besides the <code>satellite</code> basemap, you can use any of the following basemaps returned by the <code>get_basemaps()</code> function:</p> In\u00a0[\u00a0]: Copied! <pre># get_basemaps().keys()\n</pre> # get_basemaps().keys() <p>Specify the basemap as the source.</p> In\u00a0[\u00a0]: Copied! <pre>tms_to_geotiff(output=image, bbox=bbox, zoom=20, source=\"Satellite\", overwrite=True)\n</pre> tms_to_geotiff(output=image, bbox=bbox, zoom=20, source=\"Satellite\", overwrite=True) <p>You can also use your own image. Uncomment and run the following cell to use your own image.</p> In\u00a0[\u00a0]: Copied! <pre># image = '/path/to/your/own/image.tif'\n</pre> # image = '/path/to/your/own/image.tif' <p>Display the downloaded image on the map.</p> In\u00a0[\u00a0]: Copied! <pre>m.layers[-1].visible = False  # turn off the basemap\nm.add_raster(image, layer_name=\"Image\")\nm\n</pre> m.layers[-1].visible = False  # turn off the basemap m.add_raster(image, layer_name=\"Image\") m <p></p> In\u00a0[\u00a0]: Copied! <pre>out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\ncheckpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\")\n</pre> out_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\") checkpoint = os.path.join(out_dir, \"sam_vit_h_4b8939.pth\") In\u00a0[\u00a0]: Copied! <pre>sam = SamGeo(\n    model_type=\"vit_h\",\n    checkpoint=checkpoint,\n    sam_kwargs=None,\n)\n</pre> sam = SamGeo(     model_type=\"vit_h\",     checkpoint=checkpoint,     sam_kwargs=None, ) In\u00a0[\u00a0]: Copied! <pre>mask = \"segment.tiff\"\nsam.generate(\n    image, mask, batch=True, foreground=True, erosion_kernel=(3, 3), mask_multiplier=255\n)\n</pre> mask = \"segment.tiff\" sam.generate(     image, mask, batch=True, foreground=True, erosion_kernel=(3, 3), mask_multiplier=255 ) In\u00a0[\u00a0]: Copied! <pre>vector = \"segment.gpkg\"\nsam.tiff_to_gpkg(mask, vector, simplify_tolerance=None)\n</pre> vector = \"segment.gpkg\" sam.tiff_to_gpkg(mask, vector, simplify_tolerance=None) <p>You can also save the segmentation results as any vector data format supported by GeoPandas.</p> In\u00a0[\u00a0]: Copied! <pre>shapefile = \"segment.shp\"\nsam.tiff_to_vector(mask, shapefile)\n</pre> shapefile = \"segment.shp\" sam.tiff_to_vector(mask, shapefile) In\u00a0[\u00a0]: Copied! <pre>style = {\n    \"color\": \"#3388ff\",\n    \"weight\": 2,\n    \"fillColor\": \"#7c4185\",\n    \"fillOpacity\": 0.5,\n}\nm.add_vector(vector, layer_name=\"Vector\", style=style)\nm\n</pre> style = {     \"color\": \"#3388ff\",     \"weight\": 2,     \"fillColor\": \"#7c4185\",     \"fillOpacity\": 0.5, } m.add_vector(vector, layer_name=\"Vector\", style=style) m <p></p>"},{"location":"examples/satellite/#segment-anything-model-for-geospatial-data","title":"Segment Anything Model for Geospatial Data\u00b6","text":"<p>This notebook shows how to use segment satellite imagery using the Segment Anything Model (SAM) with a few lines of code.</p> <p>Make sure you use GPU runtime for this notebook. For Google Colab, go to <code>Runtime</code> -&gt; <code>Change runtime type</code> and select <code>GPU</code> as the hardware accelerator.</p>"},{"location":"examples/satellite/#install-dependencies","title":"Install dependencies\u00b6","text":"<p>Uncomment and run the following cell to install the required dependencies.</p>"},{"location":"examples/satellite/#import-libraries","title":"Import libraries\u00b6","text":""},{"location":"examples/satellite/#create-an-interactive-map","title":"Create an interactive map\u00b6","text":""},{"location":"examples/satellite/#download-map-tiles","title":"Download map tiles\u00b6","text":"<p>Download maps tiles and mosaic them into a single GeoTIFF file</p>"},{"location":"examples/satellite/#initialize-sam-class","title":"Initialize SAM class\u00b6","text":""},{"location":"examples/satellite/#segment-the-image","title":"Segment the image\u00b6","text":"<p>Set <code>batch=True</code> to segment the image in batches. This is useful for large images that cannot fit in memory.</p>"},{"location":"examples/satellite/#polygonize-the-raster-data","title":"Polygonize the raster data\u00b6","text":"<p>Save the segmentation results as a GeoPackage file.</p>"},{"location":"examples/satellite/#visualize-the-results","title":"Visualize the results\u00b6","text":""}]}